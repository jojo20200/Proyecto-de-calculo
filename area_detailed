import math
import os
import numpy as np
import sympy as sp
from sympy import Symbol
from sympy.core.sympify import SympifyError
import matplotlib
try:
    matplotlib.use("TkAgg")
except Exception:
    pass
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
from matplotlib import animation
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox, colorchooser
import time
from PIL import Image, ImageTk
import sys
import scipy.integrate as sci_integrate
from scipy.optimize import fsolve
import matplotlib.patches as patches
from matplotlib.patches import Polygon
from matplotlib.collections import PatchCollection
# ----------------------- ESTILOS VISUALES MEJORADOS -----------------------
plt.style.use('dark_background') # Estilo moderno por defecto
# Manual implementation of numerical derivative to replace deprecated scipy.misc.derivative
def num_deriv(f, x, dx=1e-6, n=1):
    """
    Numerical derivative approximation.
    f: function to differentiate
    x: point to evaluate at
    dx: step size
    n: order of derivative (1 for first, 2 for second, etc.)
    """
    if n == 1:
        return (f(x + dx) - f(x - dx)) / (2 * dx)
    elif n == 2:
        return (f(x + dx) - 2 * f(x) + f(x - dx)) / dx**2
    else:
        # For higher orders, recurse
        return num_deriv(lambda t: num_deriv(f, t, dx=dx, n=1), x, dx=dx, n=n-1)
# ----------------------- CONFIGURACI√ìN GLOBAL MEJORADA -----------------------
class AppConfig:
    DARK_THEME = {
        "bg": "#0a0f1c",
        "card_bg": "#131a2c",
        "accent": "#00d4ff",
        "accent_secondary": "#ff6b9d",
        "accent_tertiary": "#7eff7e",
        "text_primary": "#ffffff",
        "text_secondary": "#b0b8d1",
        "text_muted": "#8a93b0",
        "success": "#00ffaa",
        "warning": "#ffd166",
        "error": "#ff6b6b",
        "border": "#1e2a45",
        "button_bg": "#1a243b",
        "button_hover": "#243355",
        "entry_bg": "#0d1424",
        "plot_bg": "#0b1220",
        "plot_grid": "#1a2a4a"
    }
   
    LIGHT_THEME = {
        "bg": "#f0f4ff",
        "card_bg": "#ffffff",
        "accent": "#0066ff",
        "accent_secondary": "#ff3366",
        "accent_tertiary": "#00cc66",
        "text_primary": "#1a1a2e",
        "text_secondary": "#4a5568",
        "text_muted": "#718096",
        "success": "#00b894",
        "warning": "#fdcb6e",
        "error": "#e84393",
        "border": "#e2e8f0",
        "button_bg": "#e2e8f0",
        "button_hover": "#cbd5e0",
        "entry_bg": "#ffffff",
        "plot_bg": "#ffffff",
        "plot_grid": "#e2e8f0"
    }
   
    ANIMATION_SPEEDS = {
        "slow": 100,
        "normal": 50,
        "fast": 20,
        "instant": 0
    }
   
    GRADIENT_COLORS = [
        '#00d4ff', '#ff6b9d', '#7eff7e', '#ffd166', '#9d4edd',
        '#ff9e64', '#4cc9f0', '#f72585', '#7209b7', '#3a86ff'
    ]
# ----------------------- UTILIDADES MATEM√ÅTICAS (MEJORADAS) -----------------------
X = sp.Symbol('x')
Y = sp.Symbol('y')
T = sp.Symbol('t')
# Constantes f√≠sicas
GRAVEDAD_TIERRA = 9.80665 # m/s¬≤ m√°s preciso
# Configuraci√≥n global de velocidad
class AnimationSpeed:
    SLOW = 100 # ms entre frames
    NORMAL = 50 # ms entre frames
    FAST = 20 # ms entre frames
    INSTANT = 0 # Sin animaci√≥n
def parse_limit_string(s):
    """Parsea un string de l√≠mite: 'inf', 'oo', '-inf', '-oo', o n√∫mero."""
    s = str(s).strip()
    if s == '':
        raise ValueError("El l√≠mite no puede ser una cadena vac√≠a.")
    sl = s.lower()
    if sl in ('inf', 'oo', '+inf', '+oo'):
        return sp.oo
    if sl in ('-inf', '-oo'):
        return -sp.oo
    try:
        return float(s)
    except ValueError:
        try:
            return sp.sympify(s)
        except SympifyError:
            raise ValueError(f"L√≠mite inv√°lido: '{s}'. Use n√∫meros, 'inf', '-inf', 'pi', o 'E'.")
def safe_sympify(expr_str, symbol_char='x'):
    """Parsea la expresi√≥n ingresada por el usuario a SymPy de forma segura."""
    if not str(expr_str).strip():
        raise ValueError("La expresi√≥n de la funci√≥n no puede estar vac√≠a.")
   
    s = str(expr_str).replace('^', '**')
   
    local = {
        'x': Symbol('x'),
        'y': Symbol('y'),
        'sin': sp.sin, 'cos': sp.cos, 'tan': sp.tan,
        'asin': sp.asin, 'acos': sp.acos, 'atan': sp.atan,
        'csc': sp.csc, 'sec': sp.sec, 'cot': sp.cot,
        'sinh': sp.sinh, 'cosh': sp.cosh, 'tanh': sp.tanh,
        'asinh': sp.asinh, 'acosh': sp.acosh, 'atanh': sp.atanh,
        'exp': sp.exp, 'log': sp.log, 'ln': sp.log,
        'sqrt': sp.sqrt, 'pi': sp.pi, 'E': sp.E,
        'abs': sp.Abs, 'factorial': sp.factorial
    }
   
    try:
        expr = sp.sympify(s, locals=local)
        return expr
    except (SympifyError, SyntaxError) as e:
        raise ValueError(f"Error de sintaxis en la expresi√≥n: '{expr_str}'.\n\nCausa: {e}\n\nRevise la sintaxis. Use '*' para multiplicar (ej. 2*x) y '**' para potencias (ej. x**2).")
    except Exception as e:
        raise ValueError(f"Error desconocido al procesar la expresi√≥n: {e}")
# ----------------------- F√çSICA ENGINE MEJORADO CON M√âTODOS AVANZADOS -----------------------
class PhysicsEngine:
    def __init__(self):
        self.g = GRAVEDAD_TIERRA
        self._cache = {}
   
    def _cache_key(self, method, *args):
        return f"{method}_{'_'.join(map(str, args))}"
   
    def caida_libre_tiempo(self, altura, velocidad_inicial=0, densidad_aire=1.225,
                          coeficiente_arrastre=0.5, area=0.1, masa=1.0):
        """Ca√≠da libre con resistencia del aire usando EDOs"""
        cache_key = self._cache_key("caida_tiempo", altura, velocidad_inicial,
                                  densidad_aire, coeficiente_arrastre, area, masa)
        if cache_key in self._cache:
            return self._cache[cache_key]
          
        try:
            # Sin resistencia del aire (soluci√≥n anal√≠tica)
            if velocidad_inicial == 0:
                tiempo_simple = math.sqrt(2 * altura / self.g)
            else:
                a = 0.5 * self.g
                b = velocidad_inicial
                c = -altura
                discriminante = b**2 - 4*a*c
                if discriminante < 0:
                    raise ValueError("No hay soluci√≥n real para estos par√°metros")
                tiempo_simple = (-b + math.sqrt(discriminante)) / (2*a)
                if tiempo_simple < 0:
                    tiempo_simple = (-b - math.sqrt(discriminante)) / (2*a)
          
            # Con resistencia del aire (soluci√≥n num√©rica)
            def derivada_caida(t, y):
                # y[0] = posici√≥n, y[1] = velocidad
                fuerza_gravedad = masa * self.g
                fuerza_arrastre = 0.5 * densidad_aire * coeficiente_arrastre * area * y[1]**2
                if y[1] >= 0:
                    fuerza_arrestre = -fuerza_arrastre
                aceleracion = (fuerza_gravedad + fuerza_arrastre) / masa
                return [y[1], aceleracion]
          
            # Resolver EDO
            from scipy.integrate import solve_ivp
            sol = solve_ivp(derivada_caida, [0, tiempo_simple*2],
                          [altura, -velocidad_inicial],
                          method='RK45', dense_output=True)
          
            # Encontrar tiempo de impacto
            def altura_cero(t):
                return sol.sol(t)[0]
          
            tiempo_con_resistencia = fsolve(altura_cero, tiempo_simple)[0]
            velocidad_impacto = sol.sol(tiempo_con_resistencia)[1]
          
            result = {
                'tiempo_sin_resistencia': tiempo_simple,
                'tiempo_con_resistencia': tiempo_con_resistencia,
                'velocidad_impacto': abs(velocidad_impacto),
                'energia_cinetica': 0.5 * masa * velocidad_impacto**2,
                'altura': altura,
                'velocidad_inicial': velocidad_inicial,
                'diferencia_tiempo': tiempo_con_resistencia - tiempo_simple
            }
          
            self._cache[cache_key] = result
            return result
        except Exception as e:
            raise ValueError(f"Error en c√°lculo de ca√≠da libre: {e}")
  
    def movimiento_proyectil(self, velocidad, angulo, altura_inicial=0,
                           densidad_aire=1.225, coeficiente_arrastre=0.5,
                           area=0.01, masa=0.1):
        """Movimiento de proyectil con resistencia del aire"""
        angulo_rad = math.radians(angulo)
        vx0 = velocidad * math.cos(angulo_rad)
        vy0 = velocidad * math.sin(angulo_rad)
      
        def derivadas_proyectil(t, y):
            # y[0] = x, y[1] = y, y[2] = vx, y[3] = vy
            v = math.sqrt(y[2]**2 + y[3]**2)
            fuerza_arrastre = 0.5 * densidad_aire * coeficiente_arrastre * area * v**2
          
            ax = - (fuerza_arrastre / masa) * (y[2] / v) if v > 0 else 0
            ay = -self.g - (fuerza_arrastre / masa) * (y[3] / v) if v > 0 else -self.g
          
            return [y[2], y[3], ax, ay]
      
        from scipy.integrate import solve_ivp
        sol = solve_ivp(derivadas_proyectil, [0, 10],
                       [0, altura_inicial, vx0, vy0],
                       method='RK45', dense_output=True,
                       events=lambda t, y: y[1]) # Evento cuando y=0 (suelo)
      
        tiempo_vuelo = sol.t_events[0][0] if sol.t_events[0].size > 0 else sol.t[-1]
        alcance = sol.sol(tiempo_vuelo)[0]
        altura_maxima = np.max(sol.sol(sol.t)[1])
      
        return {
            'alcance': alcance,
            'altura_maxima': altura_maxima,
            'tiempo_vuelo': tiempo_vuelo,
            'velocidad_inicial': velocidad,
            'angulo': angulo,
            'trayectoria': sol
        }
   
    def caida_libre_velocidad(self, velocidad_final, velocidad_inicial=0):
        cache_key = self._cache_key("caida_velocidad", velocidad_final, velocidad_inicial)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        try:
            altura = (velocidad_final**2 - velocidad_inicial**2) / (2 * self.g)
            tiempo = (velocidad_final - velocidad_inicial) / self.g
           
            result = {
                'altura': altura,
                'tiempo': tiempo,
                'velocidad_final': velocidad_final,
                'velocidad_inicial': velocidad_inicial
            }
           
            self._cache[cache_key] = result
            return result
        except Exception as e:
            raise ValueError(f"Error en c√°lculo de altura por velocidad: {e}")
   
    def movimiento_rectilineo(self, velocidad_inicial, aceleracion, tiempo):
        cache_key = self._cache_key("movimiento", velocidad_inicial, aceleracion, tiempo)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        try:
            desplazamiento = velocidad_inicial * tiempo + 0.5 * aceleracion * tiempo**2
            velocidad_final = velocidad_inicial + aceleracion * tiempo
           
            # A√±adir an√°lisis de energ√≠a (asumiendo masa=1)
            energia_cinetica_inicial = 0.5 * velocidad_inicial**2
            energia_cinetica_final = 0.5 * velocidad_final**2
            trabajo = aceleracion * desplazamiento # Trabajo de la fuerza neta
           
            result = {
                'desplazamiento': desplazamiento,
                'velocidad_final': velocidad_final,
                'velocidad_inicial': velocidad_inicial,
                'aceleracion': aceleracion,
                'tiempo': tiempo,
                'energia_cinetica_inicial': energia_cinetica_inicial,
                'energia_cinetica_final': energia_cinetica_final,
                'trabajo': trabajo,
                'espacio_fase': {
                    'posiciones': np.linspace(0, desplazamiento, 100),
                    'velocidades': velocidad_inicial + aceleracion * np.linspace(0, tiempo, 100)
                }
            }
           
            self._cache[cache_key] = result
            return result
        except Exception as e:
            raise ValueError(f"Error en c√°lculo de movimiento rectil√≠neo: {e}")
   
    def velocidad_promedio(self, distancia_total, tiempo_total):
        cache_key = self._cache_key("velocidad_promedio", distancia_total, tiempo_total)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        try:
            velocidad_promedio = distancia_total / tiempo_total
           
            # A√±adir conversi√≥n a km/h y mph para nivel ingenier√≠a
            kmh = velocidad_promedio * 3.6
            mph = velocidad_promedio * 2.23694
           
            result = {
                'velocidad_promedio': velocidad_promedio,
                'kmh': kmh,
                'mph': mph,
                'distancia_total': distancia_total,
                'tiempo_total': tiempo_total
            }
           
            self._cache[cache_key] = result
            return result
        except Exception as e:
            raise ValueError(f"Error en c√°lculo de velocidad promedio: {e}")
   
    def analisis_energia_cinetica(self, masa, velocidad):
        """An√°lisis completo de energ√≠a cin√©tica"""
        energia = 0.5 * masa * velocidad**2
        momento_lineal = masa * velocidad
        presion_impacto = momento_lineal / 0.01 # Asumiendo √°rea de impacto de 0.01 m¬≤
      
        return {
            'energia_cinetica': energia,
            'momento_lineal': momento_lineal,
            'presion_impacto': presion_impacto,
            'velocidad_relativista': self._correccion_relativista(velocidad, masa),
            'equivalente_tnt': energia / 4.184e6 # Equivalente en kg de TNT
        }
  
    def _correccion_relativista(self, velocidad, masa):
        """Correcci√≥n relativista para velocidades altas"""
        c = 299792458 # Velocidad de la luz
        if velocidad > 0.1 * c:
            gamma = 1 / math.sqrt(1 - (velocidad/c)**2)
            return gamma * masa
        return masa
   
    def resistencia_aire_aproximada(self, masa, area, coeficiente_arrastre=0.47, # Coeficiente m√°s realista para esfera
                                  densidad_aire=1.225, velocidad=10): # Densidad a nivel del mar
        cache_key = self._cache_key("resistencia", masa, area, coeficiente_arrastre, densidad_aire, velocidad)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        try:
            fuerza_resistencia = 0.5 * densidad_aire * velocidad**2 * area * coeficiente_arrastre
            velocidad_terminal = math.sqrt((2 * masa * self.g) /
                                         (densidad_aire * area * coeficiente_arrastre))
           
            # Simulaci√≥n num√©rica simple para trayectoria con resistencia (usando SciPy ODE)
            def ode(t, y):
                pos, vel = y
                accel = -self.g - (0.5 * densidad_aire * vel**2 * area * coeficiente_arrastre / masa) * np.sign(vel)
                return [vel, accel]
           
            sol = sci_integrate.solve_ivp(ode, [0, 10], [0, 0], t_eval=np.linspace(0, 10, 100))
            tiempo_terminal_approx = sol.t[-1] # Aproximaci√≥n
           
            result = {
                'fuerza_resistencia': fuerza_resistencia,
                'velocidad_terminal': velocidad_terminal,
                'peso': masa * self.g,
                'relacion_resistencia_peso': fuerza_resistencia / (masa * self.g),
                'tiempo_aprox_terminal': tiempo_terminal_approx,
                'trayectoria': sol.y[0] # Posiciones
            }
           
            self._cache[cache_key] = result
            return result
        except Exception as e:
            raise ValueError(f"Error en c√°lculo de resistencia del aire: {e}")
   
    def clear_cache(self):
        self._cache.clear()
# ----------------------- MATH ENGINE MEJORADO A NIVEL INGENIER√çA -----------------------
class MathEngine:
    def __init__(self):
        self.x = X
        self.physics = PhysicsEngine()
        self._cache = {}
    def _cache_key(self, method, *args):
        return f"{method}_{'_'.join(map(str, args))}"
    def derivative(self, func_str, order=1, method="directo"):
        cache_key = self._cache_key("derivative", func_str, order, method)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"EXPRESI√ìN ORIGINAL: f(x) = {sp.latex(expr)}"]
       
        if method == "directo":
            d = sp.diff(expr, self.x, order)
            steps.append(f"DERIVADA {order}¬™ (DIRECTA): f'{'‚Ä≤'*order}(x) = {sp.latex(d)}")
            steps.append(f"SIMPLIFICADA: {sp.latex(sp.simplify(d))}")
        elif method == "regla_potencia":
            # Implementaci√≥n manual para regla de potencia
            terms = expr.as_ordered_terms()
            d_terms = []
            for term in terms:
                coeff, pow = term.as_coeff_pow(self.x)
                if pow > 0:
                    d_terms.append(coeff * pow * self.x**(pow-1))
            d = sum(d_terms)
            steps.append(f"APLICANDO REGLA DE POTENCIA A CADA T√âRMINO")
            steps.append(f"DERIVADA: {sp.latex(d)}")
        # Agregar m√°s m√©todos manuales para cadena, producto, etc.
        else:
            # M√©todo completo paso a paso
            d = expr
            for i in range(order):
                d = sp.diff(d, self.x)
                steps.append(f"PASO {i+1}: DERIVADA PARCIAL = {sp.latex(d)}")
            steps.append(f"DERIVADA FINAL: {sp.latex(sp.simplify(d))}")
           
        # A√±adir an√°lisis num√©rico para verificaci√≥n
        f_num = sp.lambdify(self.x, expr, 'numpy')
        d_num = lambda x_val: num_deriv(f_num, x_val, dx=1e-6, n=order)
        test_point = 1.0
        num_val = d_num(test_point)
        steps.append(f"VERIFICACI√ìN NUM√âRICA EN x={test_point}: ‚âà {num_val:.6f}")
       
        result = (d, steps)
        self._cache[cache_key] = result
        return result
    def eval_derivative(self, func_str, point, order=1, method="directo"):
        cache_key = self._cache_key("eval_derivative", func_str, point, order, method)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        d = sp.diff(expr, self.x, order)
        try:
            val_sym = sp.N(d.subs(self.x, point))
            steps = [f"f(x) = {sp.latex(expr)}", f"DERIVADA {order}¬™: {sp.latex(d)}", f"EVALUADA EN x={point}: {val_sym}"]
           
            # Verificaci√≥n num√©rica
            f_num = sp.lambdify(self.x, expr, 'numpy')
            val_num = num_deriv(f_num, point, dx=1e-8, n=order)
            steps.append(f"VERIFICACI√ìN NUM√âRICA: ‚âà {val_num:.8f} (error relativo: {abs(val_sym - val_num)/abs(val_sym):.2e})")
            result = (val_sym, steps)
            self._cache[cache_key] = result
            return result
        except Exception as e:
            result = (None, [f"No fue posible evaluar la derivada en {point}: {e}"])
            self._cache[cache_key] = result
            return result
    def indefinite(self, func_str):
        cache_key = self._cache_key("indefinite", func_str)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        try:
            res = sp.integrate(expr, self.x)
            steps = [f"f(x) = {sp.latex(expr)}", f"‚à´ f(x) dx = {sp.latex(res)} + C"]
            # A√±adir verificaci√≥n diferenciando
            diff_back = sp.diff(res, self.x)
            steps.append(f"VERIFICACI√ìN: d/dx (resultado) = {sp.latex(diff_back)} (debe coincidir con original)")
            result = (res, steps)
            self._cache[cache_key] = result
            return result
        except Exception as e:
            result = (None, [f"No se pudo integrar simb√≥licamente: {e}"])
            self._cache[cache_key] = result
            return result
    def definite(self, func_str, a, b):
        cache_key = self._cache_key("definite", func_str, a, b)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        try:
            res_sym = sp.integrate(expr, (self.x, a, b))
            steps = [f"f(x) = {sp.latex(expr)}", f"Intervalo: [{a}, {b}]", f"RESULTADO SIMB√ìLICO: {res_sym}"]
           
            # A√±adir aproximaci√≥n num√©rica con SciPy para precisi√≥n
            f_num = sp.lambdify(self.x, expr, 'numpy')
            res_num, err = sci_integrate.quad(f_num, a, b)
            steps.append(f"APROXIMACI√ìN NUM√âRICA (QUAD): {res_num:.10f} ¬± {err:.2e}")
            result = (res_sym, steps)
            self._cache[cache_key] = result
            return result
        except Exception as e:
            try:
                # Fallback a num√©rico si simb√≥lico falla
                f_num = sp.lambdify(self.x, expr, 'numpy')
                res_num, err = sci_integrate.quad(f_num, a, b)
                steps = [f"NUM√âRICO (QUAD): {res_num:.10f} ¬± {err:.2e}"]
                result = (res_num, steps)
                self._cache[cache_key] = result
                return result
            except Exception as e2:
                result = (None, [f"No se pudo calcular integral definida: {e2}"])
                self._cache[cache_key] = result
                return result
    def improper(self, func_str, a, b):
        cache_key = self._cache_key("improper", func_str, a, b)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"f(x) = {sp.latex(expr)}", f"Intentando integral impropia en [{a}, {b}]"]
        try:
            res = sp.integrate(expr, (self.x, a, b))
            steps.append(f"RESULTADO SIMB√ìLICO: {res}")
            # Verificaci√≥n num√©rica con l√≠mites finitos
            if sp.oo in (a, b) or -sp.oo in (a, b):
                finite_a = -1e6 if a == -sp.oo else a
                finite_b = 1e6 if b == sp.oo else b
                f_num = sp.lambdify(self.x, expr, 'numpy')
                res_num, err = sci_integrate.quad(f_num, finite_a, finite_b)
                steps.append(f"APROXIMACI√ìN NUM√âRICA (FINITA): {res_num:.10f} ¬± {err:.2e}")
            result = (res, steps)
            self._cache[cache_key] = result
            return result
        except Exception as e:
            steps.append(f"Error simb√≥lico: {e}. Usando num√©rico.")
            try:
                f_num = sp.lambdify(self.x, expr, 'numpy')
                res_num, err = sci_integrate.quad(f_num, a, b, limit=1000)
                steps.append(f"NUM√âRICO (QUAD IMPROPIO): {res_num:.10f} ¬± {err:.2e}")
                result = (res_num, steps)
            except:
                result = (None, steps)
            self._cache[cache_key] = result
            return result
    def partial_fractions(self, func_str):
        cache_key = self._cache_key("partial_fractions", func_str)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"EXPRESI√ìN ORIGINAL: {sp.latex(expr)}"]
        try:
            decomposed = sp.apart(expr, self.x)
            steps.append(f"DESCOMPOSICI√ìN: {sp.latex(decomposed)}")
            integ = sp.integrate(decomposed, self.x)
            steps.append(f"INTEGRAL: {sp.latex(integ)} + C")
            # Verificaci√≥n diferenciando
            diff_back = sp.diff(integ, self.x)
            steps.append(f"VERIFICACI√ìN: d/dx = {sp.latex(diff_back)}")
            result = (integ, steps)
            self._cache[cache_key] = result
            return result
        except Exception as e:
            result = (None, [f"No es una fracci√≥n racional o error: {e}"])
            self._cache[cache_key] = result
            return result
    def integration_by_parts_auto(self, func_str):
        cache_key = self._cache_key("integration_by_parts", func_str)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"EXPRESI√ìN: {sp.latex(expr)}", "M√âTODO: POR PARTES (LIATE)"]
        try:
            from sympy.integrals.manualintegrate import integral_steps
            steps_obj = integral_steps(expr, self.x)
            # Extraer pasos detallados
            for rule in steps_obj:
                steps.append(f"PASO: {rule.rule} - u={rule.u}, dv={rule.dv}")
            result = sp.integrate(expr, self.x)
            steps.append(f"RESULTADO: {sp.latex(result)} + C")
            result_final = (result, steps)
            self._cache[cache_key] = result_final
            return result_final
        except Exception as e:
            result_final = (None, steps + [f"Error: {e}"])
            self._cache[cache_key] = result_final
            return result_final
    def substitution_auto(self, func_str):
        cache_key = self._cache_key("substitution", func_str)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"FUNCI√ìN: {sp.latex(expr)}", "SUSTITUCI√ìN AUTOM√ÅTICA"]
        try:
            from sympy.integrals.manualintegrate import integral_steps
            steps_obj = integral_steps(expr, self.x)
            for rule in steps_obj:
                if hasattr(rule, 'substitution'):
                    steps.append(f"SUSTITUCI√ìN: u = {rule.substitution}")
            result = sp.integrate(expr, self.x)
            steps.append(f"RESULTADO: {sp.latex(result)} + C")
            result_final = (result, steps)
            self._cache[cache_key] = result_final
            return result_final
        except Exception as e:
            result_final = (None, steps + [f"Error: {e}"])
            self._cache[cache_key] = result_final
            return result_final
    def trig_substitution(self, func_str):
        cache_key = self._cache_key("trig_substitution", func_str)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        steps = [f"FUNCI√ìN: {sp.latex(expr)}", "SUSTITUCI√ìN TRIGONOM√âTRICA"]
        try:
            result = sp.integrate(expr, self.x)
            # Detectar tipo de sust. trig.
            if 'sqrt(x**2 + ' in str(expr):
                steps.append("TIPO: x = a tan(Œ∏) o similar")
            steps.append(f"RESULTADO: {sp.latex(result)} + C")
            result_final = (result, steps)
            self._cache[cache_key] = result_final
            return result_final
        except Exception as e:
            result_final = (None, steps + [f"Error: {e}"])
            self._cache[cache_key] = result_final
            return result_final
    def numeric_simpson(self, func_str, a, b, n=10000): # Aumentado n para precisi√≥n
        cache_key = self._cache_key("numeric_simpson", func_str, a, b, n)
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        f = sp.lambdify(self.x, expr, 'numpy')
       
        if n % 2 != 0:
            n += 1
           
        xs = np.linspace(float(a), float(b), n + 1)
       
        try:
            with np.errstate(all='ignore'):
                ys = f(xs)
        except Exception as e:
            raise ValueError(f"No se pudo evaluar la funci√≥n num√©ricamente: {e}")
        ys = np.nan_to_num(ys, nan=0.0, posinf=1e100, neginf=-1e100)
       
        h = (float(b) - float(a)) / n
        integral = (h / 3) * (ys[0] + 4 * np.sum(ys[1:-1:2]) + 2 * np.sum(ys[2:-2:2]) + ys[-1])
       
        # A√±adir error estimado (regla de Simpson)
        error_est = - ( (b-a)**5 / (180 * n**4) ) * max(np.abs(ys)) # Aproximaci√≥n burda
       
        steps = [f"REGLA DE SIMPSON CON n={n} SUBINTERVALOS",
                 f"RESULTADO APROXIMADO: {integral:.12f}",
                 f"ERROR ESTIMADO: ‚âà {error_est:.2e}"]
        result = (float(integral), steps)
        self._cache[cache_key] = result
        return result
   
    def critical_points(self, func_str, xlim=(-5, 5)):
        cache_key = self._cache_key("critical_points", func_str, xlim[0], xlim[1])
        if cache_key in self._cache:
            return self._cache[cache_key]
           
        expr = safe_sympify(func_str, 'x')
        fprime = sp.diff(expr, self.x)
        fsecond = sp.diff(expr, self.x, 2)
        fthird = sp.diff(expr, self.x, 3)
       
        crits = []
        try:
            # Soluci√≥n simb√≥lica
            sols_sym = sp.solve(fprime, self.x)
            sols_num = [float(s) for s in sols_sym if s.is_real and xlim[0] <= float(s) <= xlim[1]]
           
            # Suplemento num√©rico con fsolve
            fprime_num = sp.lambdify(self.x, fprime, 'numpy')
            for guess in np.linspace(xlim[0], xlim[1], 50):
                root = fsolve(fprime_num, guess)[0]
                if xlim[0] <= root <= xlim[1] and abs(fprime_num(root)) < 1e-6:
                    sols_num.append(root)
           
            sols = sorted(list(set(np.round(sols_num, 8))))
            for s in sols:
                sx = float(s)
                yv = float(expr.subs(self.x, sx))
                sec_val = float(fsecond.subs(self.x, sx))
                if sec_val == 0:
                    third_val = float(fthird.subs(self.x, sx))
                    kind = 'Inflexi√≥n' if third_val != 0 else 'Indeterminado'
                else:
                    kind = 'M√≠nimo local' if sec_val > 0 else 'M√°ximo local'
                crits.append({'x': sx, 'y': yv, 'tipo': kind, 'curvatura': sec_val})
        except Exception:
            pass
        y_intercept = {'x': 0.0, 'y': float(expr.subs(self.x, 0)) if expr.subs(self.x, 0).is_real else None, 'tipo': 'Intersecci√≥n Y'}
        x_intercepts = []
        try:
            # Ra√≠ces simb√≥licas
            roots_sym = sp.solve(expr, self.x)
            roots_num = [float(r) for r in roots_sym if r.is_real and xlim[0] <= float(r) <= xlim[1]]
           
            # Suplemento num√©rico
            f_num = sp.lambdify(self.x, expr, 'numpy')
            for guess in np.linspace(xlim[0], xlim[1], 50):
                root = fsolve(f_num, guess)[0]
                if xlim[0] <= root <= xlim[1] and abs(f_num(root)) < 1e-6:
                    roots_num.append(root)
           
            roots = sorted(list(set(np.round(roots_num, 8))))
            for r in roots:
                x_intercepts.append({'x': r, 'y': 0.0, 'tipo': 'Ra√≠z'})
        except Exception:
            pass
           
        result = {"puntos_criticos": crits, "interseccion_y": y_intercept, "raices": x_intercepts}
        self._cache[cache_key] = result
        return result
    def clear_cache(self):
        self._cache.clear()
        self.physics.clear_cache()
# ----------------------- COMPONENTES DE INTERFAZ MODERNOS -----------------------
class ModernButton(ttk.Button):
    def __init__(self, parent, **kwargs):
        style_name = kwargs.pop('style', 'Modern.TButton')
        super().__init__(parent, style=style_name, **kwargs)
class ModernEntry(ttk.Entry):
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
class ModernCombobox(ttk.Combobox):
    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)
# ----------------------- CALCULADORA COMPACTA MEJORADA -----------------------
class CompactCalculatorPad(ttk.Frame):
    def __init__(self, parent, entry_widget, theme):
        super().__init__(parent, style="Card.TFrame")
        self.entry = entry_widget
        self.theme = theme
       
        # Configurar grid para calculadora compacta
        for i in range(6):
            self.grid_rowconfigure(i, weight=1)
        for i in range(5):
            self.grid_columnconfigure(i, weight=1)
       
        # Botones matem√°ticos compactos
        math_buttons = [
            ['sin(', 'cos(', 'tan(', 'œÄ', 'e'],
            ['log(', 'ln(', '‚àö(', 'x¬≤', 'x‚Åø'],
            ['(', ')', '|x|', '1/x', 'n!'],
            ['7', '8', '9', '/', '‚å´'],
            ['4', '5', '6', '*', 'C'],
            ['1', '2', '3', '-', 'AC'],
            ['0', '.', '=', '+', '**']
        ]
       
        # Crear botones compactos
        for r, row in enumerate(math_buttons):
            for c, text in enumerate(row):
                if text in ['‚å´', 'C', 'AC']:
                    style = "Control.TButton"
                elif text in ['7', '8', '9', '4', '5', '6', '1', '2', '3', '0', '.', '=', '+', '-', '*', '/', '**']:
                    style = "Num.TButton"
                else:
                    style = "Math.TButton"
               
                btn = ModernButton(
                    self,
                    text=text,
                    command=lambda t=text: self.on_press(t),
                    style=style
                )
                btn.grid(row=r, column=c, sticky="nsew", padx=1, pady=1)
   
    def get_display_text(self, text):
        symbol_map = {
            'sin(': 'sin', 'cos(': 'cos', 'tan(': 'tan',
            'log(': 'log', 'ln(': 'ln', '‚àö(': '‚àö',
            'œÄ': 'œÄ', 'e': 'e', '|x|': '|x|',
            'x¬≤': 'x¬≤', 'x‚Åø': 'x‚Åø', '1/x': '¬π/‚Çì', 'n!': 'n!'
        }
        return symbol_map.get(text, text)
   
    def on_press(self, value):
        if value == '=':
            try:
                # Evaluar la expresi√≥n actual
                expr = self.entry.get()
                result = str(sp.sympify(expr.replace('^', '**')))
                self.entry.delete(0, tk.END)
                self.entry.insert(0, result)
            except:
                messagebox.showerror("Error", "No se pudo evaluar la expresi√≥n")
        elif value == '‚å´':
            cursor_pos = self.entry.index(tk.INSERT)
            if cursor_pos > 0:
                self.entry.delete(cursor_pos - 1, cursor_pos)
        elif value == 'C':
            self.entry.delete(0, tk.END)
        elif value == 'AC':
            self.entry.delete(0, tk.END)
        else:
            self.entry.insert(tk.INSERT, value)
        self.entry.focus_set()
# ----------------------- GESTOR DE GR√ÅFICAS MEJORADO CON AN√ÅLISIS DE √ÅREA DETALLADO -----------------------
class ModernPlotManager:
    def __init__(self, fig, ax, canvas, theme):
        self.fig = fig
        self.ax = ax
        self.canvas = canvas
        self.theme = theme
        self.anim = None
        self.bands = []
        self.annotations = []
        self.animation_speed = AnimationSpeed.NORMAL
        self.animation_enabled = False # Desactivado por defecto
        self.show_velocity = True
        self.current_plot_type = None
        self.area_info = {}
        self.ax2 = None # Eje secundario para velocidad
        self._apply_modern_style()
    def _apply_modern_style(self):
        """Estilo moderno y atractivo para j√≥venes"""
        # Fondo con gradiente moderno
        self.fig.patch.set_facecolor(self.theme['plot_bg'])
        self.ax.set_facecolor(self.theme['plot_bg'])
       
        # Estilo de ejes moderno
        self.ax.tick_params(colors=self.theme['text_primary'], which='both', labelsize=10)
        self.ax.xaxis.label.set_color(self.theme['text_primary'])
        self.ax.yaxis.label.set_color(self.theme['text_primary'])
        self.ax.title.set_color(self.theme['accent'])
        self.ax.title.set_fontweight('bold')
        self.ax.title.set_fontsize(14)
       
        # Ejes con estilo moderno
        self.ax.spines['top'].set_visible(False)
        self.ax.spines['right'].set_visible(False)
        self.ax.spines['left'].set_color(self.theme['accent'])
        self.ax.spines['bottom'].set_color(self.theme['accent'])
        self.ax.spines['left'].set_linewidth(2)
        self.ax.spines['bottom'].set_linewidth(2)
       
        # Grid moderno
        self.ax.grid(True, linestyle='--', linewidth=0.7, color=self.theme['plot_grid'], alpha=0.8)
        self.ax.axhline(0, color=self.theme['accent'], linewidth=2, alpha=0.9)
        self.ax.axvline(0, color=self.theme['accent'], linewidth=2, alpha=0.9)
       
        self.ax.set_axisbelow(True)
    def _apply_3d_style(self):
        """Estilo moderno para 3D"""
        self.fig.patch.set_facecolor(self.theme['plot_bg'])
        self.ax.set_facecolor(self.theme['plot_bg'])
        self.ax.xaxis.label.set_color(self.theme['text_primary'])
        self.ax.yaxis.label.set_color(self.theme['text_primary'])
        self.ax.zaxis.label.set_color(self.theme['text_primary'])
        self.ax.tick_params(colors=self.theme['text_primary'], which='both', labelsize=10)
        self.ax.title.set_color(self.theme['accent'])
        self.ax.title.set_fontweight('bold')
        self.ax.title.set_fontsize(14)
        self.ax.view_init(elev=20, azim=45)
    def set_animation_speed(self, speed):
        self.animation_speed = speed
    def toggle_animation(self):
        self.animation_enabled = not self.animation_enabled
        return self.animation_enabled
    def toggle_velocity(self):
        self.show_velocity = not self.show_velocity
        return self.show_velocity
    def clear(self):
        """Limpieza completa que incluye el eje secundario"""
        if self.anim:
            try:
                self.anim.event_source.stop()
            except AttributeError:
                pass
            self.anim = None
       
        # Limpiar eje secundario si existe
        if self.ax2 is not None:
            try:
                self.ax2.remove()
                self.ax2 = None
            except:
                pass
       
        for artist in self.annotations:
            try:
                artist.remove()
            except (ValueError, AttributeError):
                pass
        self.annotations.clear()
        for band in self.bands:
            try:
                band.remove()
            except (ValueError, AttributeError):
                pass
        self.bands.clear()
       
        self.ax.cla()
        if self.current_plot_type == "3d":
            self._apply_3d_style()
        else:
            self._apply_modern_style()
       
        self.current_plot_type = None
        self.area_info = {}
       
        self.canvas.draw_idle()
    def plot_function(self, func_str, xlim=(-5,5), color_index=0, animate=True, show_area=True, area_limits=None):
        self.current_plot_type = "function"
        self.fig.clear()
        self.ax = self.fig.add_subplot(111)
       
        expr = safe_sympify(func_str)
        f = sp.lambdify(X, expr, 'numpy')
       
        xs = np.linspace(float(xlim[0]), float(xlim[1]), 2000)
       
        with np.errstate(divide='ignore', invalid='ignore'):
            ys = f(xs)
       
        ys = np.array(ys, dtype=float)
        mask_finite = np.isfinite(ys)
       
        if not np.any(mask_finite):
            raise ValueError("La funci√≥n no produce valores finitos en el intervalo especificado.")
       
        color = AppConfig.GRADIENT_COLORS[color_index % len(AppConfig.GRADIENT_COLORS)]
       
        # Gr√°fica principal con estilo moderno
        line, = self.ax.plot(xs[mask_finite], ys[mask_finite],
                           linewidth=3, color=color, alpha=0.95, solid_capstyle='round',
                           label=f"f(x) = {sp.simplify(expr)}", zorder=5)
        self.ax.set_xlim(xlim)
       
        # Ajuste autom√°tico de l√≠mites Y
        valid_ys = ys[mask_finite]
        if valid_ys.size > 0:
            q1, q3 = np.percentile(valid_ys, [25, 75])
            iqr = q3 - q1
            lower_bound = q1 - 2 * iqr
            upper_bound = q3 + 2 * iqr
           
            reasonable_ys = valid_ys[(valid_ys >= lower_bound) & (valid_ys <= upper_bound)]
           
            if reasonable_ys.size > 0:
                y_margin = (np.max(reasonable_ys) - np.min(reasonable_ys)) * 0.15
                y_min = np.min(reasonable_ys) - y_margin
                y_max = np.max(reasonable_ys) + y_margin
                self.ax.set_ylim(y_min, y_max)
       
        # √Årea bajo la curva con informaci√≥n detallada
        if show_area and area_limits and area_limits[0] is not None and area_limits[1] is not None:
            try:
                a, b = area_limits
                if xlim[0] <= a <= xlim[1] and xlim[0] <= b <= xlim[1]:
                    area_data = self._shade_area_detailed(func_str, a, b, color)
                    self.area_info = area_data
                   
                    # Mostrar informaci√≥n num√©rica detallada en la gr√°fica
                    self._display_area_analysis(area_data, a, b)
                   
            except Exception as e:
                print(f"Error en √°rea: {e}")
       
        # Leyenda moderna
        if func_str.strip():
            self.ax.legend(facecolor=self.theme['card_bg'], edgecolor=self.theme['border'],
                          labelcolor=self.theme['text_primary'], fontsize='small',
                          loc='upper right', framealpha=0.95, shadow=True)
       
        self._apply_modern_style()
        self.canvas.draw_idle()
    def plot_3d_function(self, func_str, xlims=(-5,5), ylims=(-5,5)):
        self.current_plot_type = "3d"
        self.fig.clear()
        self.ax = self.fig.add_subplot(111, projection='3d')
       
        try:
            expr = safe_sympify(func_str)
            f = sp.lambdify((X, Y), expr, 'numpy')
           
            nx = 50
            ny = 50
            xx = np.linspace(xlims[0], xlims[1], nx)
            yy = np.linspace(ylims[0], ylims[1], ny)
            XX, YY = np.meshgrid(xx, yy)
           
            with np.errstate(divide='ignore', invalid='ignore'):
                ZZ = f(XX, YY)
           
            ZZ = np.nan_to_num(ZZ, nan=0.0)
           
            surf = self.ax.plot_surface(XX, YY, ZZ, cmap='viridis', alpha=0.8)
            self.ax.set_xlabel('X')
            self.ax.set_ylabel('Y')
            self.ax.set_zlabel('Z = f(x,y)')
            self.ax.set_title(f'z = {sp.simplify(expr)}')
           
            self._apply_3d_style()
            self.canvas.draw_idle()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo generar la gr√°fica 3D:\n{str(e)}")
    def _shade_area_detailed(self, func_str, a, b, color):
        """Sombrea √°rea con informaci√≥n detallada como en la imagen"""
        expr = safe_sympify(func_str)
        f = sp.lambdify(X, expr, 'numpy')
       
        xs_area = np.linspace(float(a), float(b), 1000)
        with np.errstate(all='ignore'):
            ys_area = f(xs_area)
        ys_area = np.nan_to_num(ys_area, nan=0.0)
       
        # Calcular √°reas detalladas
        area_pos, area_neg, area_total, area_abs = self._calculate_area_detailed(func_str, a, b)
       
        # Sombrear √°reas positivas y negativas con estilos diferentes
        mask_pos = ys_area >= 0
        if np.any(mask_pos):
            # √Årea sobre la curva (positiva) - azul claro
            self.ax.fill_between(xs_area[mask_pos], 0, ys_area[mask_pos],
                               alpha=0.6, color='#ADD8E6', edgecolor='#ADD8E6', linewidth=2,
                               linestyle='-', label='√Årea sobre curva', zorder=3,
                               hatch='//')
       
        mask_neg = ys_area < 0
        if np.any(mask_neg):
            # √Årea bajo la curva (negativa) - rojo
            self.ax.fill_between(xs_area[mask_neg], ys_area[mask_neg], 0,
                               alpha=0.6, color='#FF0000',
                               edgecolor='#FF0000',
                               linewidth=2, linestyle='-', label='√Årea bajo curva', zorder=3,
                               hatch='\\\\')
       
        # L√≠nea del √°rea m√°s destacada
        self.ax.plot(xs_area, ys_area, color=color, alpha=0.9, linewidth=3.5, zorder=4)
       
        # Informaci√≥n del √°rea
        area_data = {
            'area_positiva': area_pos,
            'area_negativa': area_neg,
            'area_neta': area_total,
            'area_absoluta': area_abs,
            'porcentaje_positivo': (area_pos / area_abs) * 100 if area_abs != 0 else 0,
            'porcentaje_negativo': (area_neg / area_abs) * 100 if area_abs != 0 else 0
        }
       
        return area_data
    def _display_area_analysis(self, area_data, a, b):
        """Muestra el an√°lisis de √°rea en la gr√°fica como en la imagen"""
        # Crear texto con formato similar a la imagen
        info_text = f"""üìä AN√ÅLISIS DE √ÅREA [{a:.2f}, {b:.2f}]
√Årea sobre curva: {area_data['area_positiva']:.6f}
√Årea bajo curva: {area_data['area_negativa']:.6f}
√Årea neta: {area_data['area_neta']:.6f}
√Årea total: {area_data['area_absoluta']:.6f}
Distribuci√≥n:
‚Ä¢ Positiva: {area_data['porcentaje_positivo']:.1f}%
‚Ä¢ Negativa: {area_data['porcentaje_negativo']:.1f}%"""
       
        # Posicionar la anotaci√≥n en una esquina
        x_pos = 0.02
        y_pos = 0.98
       
        # Crear anotaci√≥n con estilo similar a la imagen
        ann = self.ax.annotate(info_text,
                             xy=(x_pos, y_pos),
                             xycoords='axes fraction',
                             fontsize=10,
                             color=self.theme['text_primary'],
                             weight='bold',
                             bbox=dict(boxstyle='round,pad=0.8',
                                     fc=self.theme['card_bg'],
                                     ec=self.theme['accent'],
                                     alpha=0.95,
                                     linewidth=3),
                             zorder=10,
                             ha='left',
                             va='top')
       
        self.annotations.append(ann)
       
        # A√±adir l√≠neas de referencia para los l√≠mites del √°rea
        self.ax.axvline(a, color=self.theme['warning'], linestyle='--', alpha=0.7, linewidth=1.5)
        self.ax.axvline(b, color=self.theme['warning'], linestyle='--', alpha=0.7, linewidth=1.5)
       
        # Etiquetas para los l√≠mites
        self.ax.text(a, self.ax.get_ylim()[0] * 0.9, f'a={a:.2f}',
                   fontsize=9, color=self.theme['warning'], ha='center', va='top')
        self.ax.text(b, self.ax.get_ylim()[0] * 0.9, f'b={b:.2f}',
                   fontsize=9, color=self.theme['warning'], ha='center', va='top')

    def _calculate_area_detailed(self, func_str, a, b):
        """Calcula √°reas detalladas: positiva, negativa, neta y absoluta"""
        expr = safe_sympify(func_str)
        f = sp.lambdify(X, expr, 'numpy')

        xs = np.linspace(float(a), float(b), 10000)
        ys = f(xs)
        ys = np.nan_to_num(ys, nan=0.0)

        # Filtrar puntos positivos
        xs_pos = xs[ys >= 0]
        ys_pos = ys[ys >= 0]
        area_pos = sci_integrate.trapz(ys_pos, xs_pos)

        # Filtrar puntos negativos
        xs_neg = xs[ys < 0]
        ys_neg = ys[ys < 0]
        area_neg = abs(sci_integrate.trapz(ys_neg, xs_neg))

        # √Årea neta (puede ser positiva o negativa)
        area_total = sci_integrate.trapz(ys, xs)

        # √Årea absoluta (suma de √°reas positivas y negativas)
        area_abs = area_pos + area_neg

        return area_pos, area_neg, area_total, area_abs


    def mark_points(self, points, color='#f59e0b', animate=True):
        # Eliminar animaciones - siempre marcar instant√°neamente
        for p in points:
            self._mark_point_instant(p, color)
           
        self.canvas.draw_idle()
    def _mark_point_instant(self, p, color):
        x, y, label = p.get('x'), p.get('y'), p.get('tipo', '')
        if x is None or y is None:
            return
       
        # Punto con efecto moderno
        dot = self.ax.scatter([x], [y], color=color, s=120, zorder=10,
                            edgecolors='white', linewidths=2.5, alpha=0.95,
                            marker='o')
       
        # Texto con estilo moderno
        ann_text = f"üéØ {label}\n({x:.4f}, {y:.4f})"
        if 'curvatura' in p:
            ann_text += f"\nüìà Curvatura: {p['curvatura']:.4f}"
       
        ann = self.ax.annotate(ann_text, (x, y),
                              textcoords="offset points",
                              xytext=(0, 25),
                              ha='center', va='bottom',
                              fontsize=9,
                              color='white',
                              weight='bold',
                              bbox=dict(boxstyle='round,pad=0.4',
                                      fc=self.theme['card_bg'],
                                      ec=color,
                                      alpha=0.95,
                                      linewidth=2))
        self.annotations.extend([dot, ann])
    def plot_physics_motion(self, physics_data, problem_type):
        """Grafica movimientos f√≠sicos con estilo moderno"""
        self.current_plot_type = "physics"
        self.clear()
       
        if problem_type == 'caida_libre':
            self._plot_caida_libre_moderna(physics_data)
        elif problem_type == 'movimiento_rectilineo':
            self._plot_movimiento_rectilineo_moderno(physics_data)
       
        # T√≠tulo moderno
        title_map = {
            'caida_libre': 'üöÄ Ca√≠da Libre - An√°lisis Completo',
            'movimiento_rectilineo': 'üìà Movimiento Rectil√≠neo'
        }
       
        self.ax.set_title(title_map.get(problem_type, 'üìä F√≠sica'),
                         fontsize=16, fontweight='bold', pad=20, color=self.theme['accent'])
       
        self.canvas.draw_idle()
    def _plot_caida_libre_moderna(self, data):
        """Grafica moderna de ca√≠da libre"""
        tiempo = data.get('tiempo_sin_resistencia', data.get('tiempo', 0))
        altura = data.get('altura', 0)
        velocidad_inicial = data.get('velocidad_inicial', 0)
       
        t_max = tiempo * 1.5
        t = np.linspace(0, t_max, 300)
       
        # Ecuaciones de movimiento
        h_t = altura - (velocidad_inicial * t + 0.5 * GRAVEDAD_TIERRA * t**2)
        h_t = np.maximum(h_t, 0)
        v_t = velocidad_inicial + GRAVEDAD_TIERRA * t
       
        self.ax.clear()
        self._apply_modern_style()
       
        # Gr√°fica de altura con estilo moderno
        color_altura = self.theme['accent']
        self.ax.plot(t, h_t, linewidth=3.5, color=color_altura,
                   label=f'üìè Altura (m)', alpha=0.9, zorder=5)
       
        # L√≠nea del suelo
        self.ax.axhline(y=0, color=self.theme['error'], linestyle='--',
                       alpha=0.8, linewidth=2, label='üõë Suelo', zorder=4)
       
        # Punto de impacto
        if tiempo <= t_max:
            impact_point = self.ax.plot([tiempo], [0], 'o', markersize=10,
                                      color=self.theme['error'],
                                      label=f'üí• Impacto: {tiempo:.4f}s', zorder=6)
       
        self.ax.set_xlabel('‚è∞ Tiempo (s)', fontsize=12, fontweight='bold')
        self.ax.set_ylabel('üìè Altura (m)', fontsize=12, fontweight='bold', color=color_altura)
        self.ax.tick_params(axis='y', labelcolor=color_altura)
       
        # Gr√°fica de velocidad en eje secundario
        if self.show_velocity:
            if self.ax2 is not None:
                self.ax2.remove()
            self.ax2 = self.ax.twinx()
           
            color_velocidad = self.theme['accent_secondary']
            self.ax2.plot(t, v_t, linewidth=2.5, color=color_velocidad,
                         linestyle='--', alpha=0.8, label='üöÄ Velocidad (m/s)', zorder=3)
            self.ax2.set_ylabel('üöÄ Velocidad (m/s)', fontsize=12,
                              fontweight='bold', color=color_velocidad)
            self.ax2.tick_params(axis='y', labelcolor=color_velocidad)
           
            # Combinar leyendas
            lines1, labels1 = self.ax.get_legend_handles_labels()
            lines2, labels2 = self.ax2.get_legend_handles_labels()
            self.ax.legend(lines1 + lines2, labels1 + labels2,
                          loc='upper right', framealpha=0.95)
        else:
            self.ax.legend(loc='upper right')
       
        self.ax.set_ylim(bottom=0)
        self.ax.set_xlim(left=0)
        self.ax.grid(True, alpha=0.3)
    def _plot_movimiento_rectilineo_moderno(self, data):
        """Grafica moderna de movimiento rectil√≠neo"""
        tiempo = data.get('tiempo', 0)
        desplazamiento = data.get('desplazamiento', 0)
        velocidad_inicial = data.get('velocidad_inicial', 0)
        aceleracion = data.get('aceleracion', 0)
       
        t = np.linspace(0, tiempo, 300)
        d_t = velocidad_inicial * t + 0.5 * aceleracion * t**2
        v_t = velocidad_inicial + aceleracion * t
       
        self.ax.clear()
        self._apply_modern_style()
       
        # Gr√°fica de desplazamiento
        color_desplazamiento = self.theme['accent']
        self.ax.plot(t, d_t, linewidth=3.5, color=color_desplazamiento,
                   label=f'üìç Desplazamiento (m)', alpha=0.9, zorder=5)
       
        # Punto final
        self.ax.plot([tiempo], [desplazamiento], 'o', markersize=10,
                   color=self.theme['success'],
                   label=f'üéØ Final: {desplazamiento:.4f}m', zorder=6)
       
        self.ax.set_xlabel('‚è∞ Tiempo (s)', fontsize=12, fontweight='bold')
        self.ax.set_ylabel('üìç Desplazamiento (m)', fontsize=12,
                         fontweight='bold', color=color_desplazamiento)
        self.ax.tick_params(axis='y', labelcolor=color_desplazamiento)
       
        # Gr√°fica de velocidad
        if self.show_velocity:
            if self.ax2 is not None:
                self.ax2.remove()
            self.ax2 = self.ax.twinx()
           
            color_velocidad = self.theme['accent_secondary']
            self.ax2.plot(t, v_t, linewidth=2.5, color=color_velocidad,
                         linestyle='--', alpha=0.8, label='üöÄ Velocidad (m/s)', zorder=4)
            self.ax2.set_ylabel('üöÄ Velocidad (m/s)', fontsize=12,
                              fontweight='bold', color=color_velocidad)
            self.ax2.tick_params(axis='y', labelcolor=color_velocidad)
           
            # Leyenda combinada
            lines1, labels1 = self.ax.get_legend_handles_labels()
            lines2, labels2 = self.ax2.get_legend_handles_labels()
            self.ax.legend(lines1 + lines2, labels1 + labels2,
                          loc='upper left', framealpha=0.95)
        else:
            self.ax.legend(loc='upper left')
       
        self.ax.set_xlim(left=0)
        if desplazamiento >= 0:
            self.ax.set_ylim(bottom=0)
        else:
            self.ax.set_ylim(top=0)
       
        self.ax.grid(True, alpha=0.3)
    def get_area_info(self):
        """Retorna informaci√≥n detallada del √°rea"""
        return self.area_info
# ----------------------- INTERFAZ PRINCIPAL MEJORADA -----------------------
class UltraCalc2DModernApp:
    def __init__(self, root):
        self.root = root
        self.root.title("üöÄ Ultra Calc 2D - Matem√°ticas Visuales Modernas")
        self.root.geometry("1400x900")
        self.root.minsize(1200, 800)
       
        # Configuraci√≥n inicial
        self.theme_mode = "dark"
        self.theme = AppConfig.DARK_THEME
        self.animation_speed = "normal"
       
        # Centrar ventana
        self._center_window()
       
        # Configurar estilos
        self.setup_styles()
       
        # Mostrar pantalla de inicio
        self._create_loading_screen()
       
        # Inicializar motores despu√©s de la pantalla de carga
        self.root.after(1500, self._initialize_components)
    def _center_window(self):
        self.root.update_idletasks()
        width = 1400
        height = 900
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f'{width}x{height}+{x}+{y}')
    def _create_loading_screen(self):
        self.loading_frame = tk.Frame(self.root, bg=self.theme['bg'])
        self.loading_frame.pack(fill=tk.BOTH, expand=True)
       
        logo_label = tk.Label(
            self.loading_frame,
            text="üßÆ",
            font=("Arial", 64),
            bg=self.theme['bg'],
            fg=self.theme['accent']
        )
        logo_label.pack(pady=50)
       
        title_label = tk.Label(
            self.loading_frame,
            text="ULTRA CALC 2D",
            font=("Arial", 32, "bold"),
            bg=self.theme['bg'],
            fg=self.theme['text_primary']
        )
        title_label.pack(pady=10)
       
        subtitle_label = tk.Label(
            self.loading_frame,
            text="Cargando experiencia matem√°tica moderna...",
            font=("Arial", 14),
            bg=self.theme['bg'],
            fg=self.theme['text_secondary']
        )
        subtitle_label.pack(pady=20)
       
        self.progress = ttk.Progressbar(
            self.loading_frame,
            mode='indeterminate',
            length=400
        )
        self.progress.pack(pady=30)
        self.progress.start(15)
    def _initialize_components(self):
        self.loading_frame.destroy()
       
        # Inicializar motor matem√°tico mejorado
        self.engine = MathEngine()
       
        # Crear interfaz principal
        self.create_modern_interface()
    def setup_styles(self):
        style = ttk.Style()
        style.theme_use('clam')
       
        style.configure(".",
                       background=self.theme['bg'],
                       foreground=self.theme['text_primary'],
                       font=("Segoe UI", 10))
       
        style.configure("Card.TFrame",
                       background=self.theme['card_bg'],
                       relief="flat",
                       borderwidth=1)
       
        style.configure("Modern.TButton",
                       background=self.theme['button_bg'],
                       foreground=self.theme['text_primary'],
                       borderwidth=0,
                       focuscolor="none",
                       padding=(12, 8),
                       font=("Segoe UI", 10, "bold"))
       
        style.map("Modern.TButton",
                 background=[('active', self.theme['button_hover']),
                           ('pressed', self.theme['accent'])],
                 foreground=[('active', self.theme['text_primary']),
                           ('pressed', self.theme['card_bg'])])
       
        style.configure("Accent.TButton",
                       background=self.theme['accent'],
                       foreground=self.theme['card_bg'],
                       borderwidth=0,
                       padding=(12, 8),
                       font=("Segoe UI", 10, "bold"))
       
        style.map("Accent.TButton",
                 background=[('active', self.theme['accent_secondary']),
                           ('pressed', self.theme['accent_tertiary'])])
       
        for btn_type, bg_color in [("Math.TButton", "#2a3b5c"),
                                  ("Num.TButton", self.theme['button_bg']),
                                  ("Control.TButton", "#4a5b7c")]:
            style.configure(btn_type,
                          background=bg_color,
                          foreground=self.theme['text_primary'],
                          borderwidth=0,
                          padding=(8, 6),
                          font=("Segoe UI", 9, "bold"))
           
            style.map(btn_type,
                     background=[('active', self.theme['button_hover']),
                               ('pressed', self.theme['accent'])])
       
        style.configure("Header.TLabel",
                       font=("Segoe UI", 16, "bold"),
                       foreground=self.theme['accent'],
                       background=self.theme['card_bg'])
       
        style.configure("CardHeader.TLabel",
                       font=("Segoe UI", 12, "bold"),
                       foreground=self.theme['accent_secondary'],
                       background=self.theme['card_bg'])
       
        style.configure("Small.TLabel",
                       font=("Segoe UI", 9),
                       foreground=self.theme['text_secondary'],
                       background=self.theme['card_bg'])
       
        style.configure("TEntry",
                       fieldbackground=self.theme['entry_bg'],
                       foreground=self.theme['text_primary'],
                       bordercolor=self.theme['border'],
                       insertcolor=self.theme['text_primary'],
                       padding=(8, 6))
       
        style.map("TEntry",
                 bordercolor=[('focus', self.theme['accent'])])
       
        style.configure("TCombobox",
                       fieldbackground=self.theme['entry_bg'],
                       background=self.theme['button_bg'],
                       foreground=self.theme['text_primary'],
                       arrowcolor=self.theme['accent'])
       
        style.configure("TNotebook",
                       background=self.theme['bg'],
                       borderwidth=0)
       
        style.configure("TNotebook.Tab",
                       background=self.theme['bg'],
                       foreground=self.theme['text_muted'],
                       padding=(15, 8),
                       borderwidth=0,
                       font=("Segoe UI", 9, "bold"))
       
        style.map("TNotebook.Tab",
                 background=[("selected", self.theme['card_bg'])],
                 foreground=[("selected", self.theme['accent'])])
       
        style.configure("Modern.Horizontal.TProgressbar",
                       background=self.theme['accent'],
                       troughcolor=self.theme['card_bg'],
                       borderwidth=0)
    def create_modern_interface(self):
        self.create_header()
       
        # Crear paned window principal con barra de desplazamiento
        main_paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        main_paned.pack(fill=tk.BOTH, expand=True, padx=15, pady=10)
       
        # Left panel con scrollbar
        left_frame = ttk.Frame(main_paned)
        left_canvas = tk.Canvas(left_frame, bg=self.theme['bg'], highlightthickness=0)
        left_scrollbar = ttk.Scrollbar(left_frame, orient="vertical", command=left_canvas.yview)
        left_scrollable_frame = ttk.Frame(left_canvas, style="Card.TFrame")
       
        left_scrollable_frame.bind(
            "<Configure>",
            lambda e: left_canvas.configure(scrollregion=left_canvas.bbox("all"))
        )
       
        left_canvas.create_window((0, 0), window=left_scrollable_frame, anchor="nw")
        left_canvas.configure(yscrollcommand=left_scrollbar.set)
       
        left_canvas.pack(side="left", fill="both", expand=True)
        left_scrollbar.pack(side="right", fill="y")
       
        main_paned.add(left_frame, weight=1)
       
        # Center panel
        center_panel = ttk.Frame(main_paned, style="Card.TFrame")
        main_paned.add(center_panel, weight=3)
       
        # Right panel con scrollbar
        right_frame = ttk.Frame(main_paned)
        right_canvas = tk.Canvas(right_frame, bg=self.theme['bg'], highlightthickness=0)
        right_scrollbar = ttk.Scrollbar(right_frame, orient="vertical", command=right_canvas.yview)
        right_scrollable_frame = ttk.Frame(right_canvas, style="Card.TFrame")
       
        right_scrollable_frame.bind(
            "<Configure>",
            lambda e: right_canvas.configure(scrollregion=right_canvas.bbox("all"))
        )
       
        right_canvas.create_window((0, 0), window=right_scrollable_frame, anchor="nw")
        right_canvas.configure(yscrollcommand=right_scrollbar.set)
       
        right_canvas.pack(side="left", fill="both", expand=True)
        right_scrollbar.pack(side="right", fill="y")
       
        main_paned.add(right_frame, weight=1)
       
        # Configurar los paneles dentro de los frames desplazables
        self.create_left_panel(left_scrollable_frame)
        self.create_center_panel(center_panel)
        self.create_right_panel(right_scrollable_frame)
       
        self.create_status_bar()
       
        # Configurar el redimensionamiento del canvas
        def configure_left_canvas(event):
            left_canvas.itemconfig(left_canvas_window, width=event.width)
        left_canvas_window = left_canvas.create_window((0, 0), window=left_scrollable_frame, anchor="nw")
        left_canvas.bind('<Configure>', configure_left_canvas)
       
        def configure_right_canvas(event):
            right_canvas.itemconfig(right_canvas_window, width=event.width)
        right_canvas_window = right_canvas.create_window((0, 0), window=right_scrollable_frame, anchor="nw")
        right_canvas.bind('<Configure>', configure_right_canvas)
    def create_header(self):
        header_frame = tk.Frame(self.root, bg=self.theme['card_bg'], height=80)
        header_frame.pack(fill=tk.X, padx=0, pady=0)
        header_frame.pack_propagate(False)
       
        logo_frame = tk.Frame(header_frame, bg=self.theme['card_bg'])
        logo_frame.pack(side=tk.LEFT, padx=20, pady=20)
       
        logo_label = tk.Label(logo_frame, text="üßÆ", font=("Arial", 24),
                            bg=self.theme['card_bg'], fg=self.theme['accent'])
        logo_label.pack(side=tk.LEFT)
       
        title_frame = tk.Frame(logo_frame, bg=self.theme['card_bg'])
        title_frame.pack(side=tk.LEFT, padx=(10, 0))
       
        title_label = tk.Label(title_frame, text="ULTRA CALC 2D",
                             font=("Segoe UI", 20, "bold"),
                             bg=self.theme['card_bg'], fg=self.theme['text_primary'])
        title_label.pack(anchor='w')
       
        subtitle_label = tk.Label(title_frame, text="Matem√°ticas Visuales Modernas",
                                font=("Segoe UI", 11),
                                bg=self.theme['card_bg'], fg=self.theme['text_secondary'])
        subtitle_label.pack(anchor='w')
       
        controls_frame = tk.Frame(header_frame, bg=self.theme['card_bg'])
        controls_frame.pack(side=tk.RIGHT, padx=20, pady=20)
       
        self.theme_btn = ModernButton(controls_frame, text="üåô Modo Noche",
                                    command=self.toggle_theme, style="Modern.TButton")
        self.theme_btn.pack(side=tk.RIGHT, padx=(10, 0))
    def create_left_panel(self, parent):
        notebook = ttk.Notebook(parent)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
       
        tabs = {
            "üéØ Funci√≥n": self.create_function_tab,
            "üåê 3D Interactivas": self.create_3d_tab,
            "üìä Derivadas": self.create_derivative_tab,
            "üìê Integrales": self.create_integral_tab,
            "üåç F√≠sica": self.create_physics_tab,
            "‚öôÔ∏è Opciones": self.create_settings_tab
        }
       
        for tab_name, tab_creator in tabs.items():
            tab_frame = ttk.Frame(notebook)
            notebook.add(tab_frame, text=tab_name)
            tab_creator(tab_frame)
    def create_function_tab(self, parent):
        func_card = self.create_modern_card(parent, "üìù Funci√≥n Principal")
        ttk.Label(func_card, text="Ingresa tu funci√≥n f(x):", style="Small.TLabel").pack(anchor='w', pady=(0, 5))
       
        self.func_entry = ModernEntry(func_card, font=("Consolas", 12))
        self.func_entry.pack(fill=tk.X, pady=(0, 10))
        self.func_entry.insert(0, "7*x - 8.5*x**2 + 3*x**3")
       
        # Calculadora compacta
        calc_card = self.create_modern_card(parent, "üßÆ Calculadora Compacta")
        self.calc_pad = CompactCalculatorPad(calc_card, self.func_entry, self.theme)
        self.calc_pad.pack(fill=tk.BOTH, expand=True, pady=5)
       
        range_card = self.create_modern_card(parent, "üìä Rango de Visualizaci√≥n")
        range_frame = ttk.Frame(range_card, style="Card.TFrame")
        range_frame.pack(fill=tk.X, pady=5)
       
        ttk.Label(range_frame, text="X min", style="Small.TLabel").grid(row=0, column=0, sticky='w')
        self.xmin_entry = ModernEntry(range_frame, width=10)
        self.xmin_entry.grid(row=1, column=0, padx=(0, 5), sticky='ew')
       
        ttk.Label(range_frame, text="X max", style="Small.TLabel").grid(row=0, column=1, sticky='w')
        self.xmax_entry = ModernEntry(range_frame, width=10)
        self.xmax_entry.grid(row=1, column=1, padx=(5, 0), sticky='ew')
       
        range_frame.columnconfigure((0, 1), weight=1)
        self.xmin_entry.insert(0, "0")
        self.xmax_entry.insert(0, "2")
       
        area_card = self.create_modern_card(parent, "üîç √Årea Bajo la Curva")
        area_frame = ttk.Frame(area_card, style="Card.TFrame")
        area_frame.pack(fill=tk.X, pady=5)
       
        ttk.Label(area_frame, text="L√≠mite inferior (a)", style="Small.TLabel").grid(row=0, column=0, sticky='w')
        self.lower_entry = ModernEntry(area_frame, width=10)
        self.lower_entry.grid(row=1, column=0, padx=(0, 5), sticky='ew')
       
        ttk.Label(area_frame, text="L√≠mite superior (b)", style="Small.TLabel").grid(row=0, column=1, sticky='w')
        self.upper_entry = ModernEntry(area_frame, width=10)
        self.upper_entry.grid(row=1, column=1, padx=(5, 0), sticky='ew')
       
        area_frame.columnconfigure((0, 1), weight=1)
        self.lower_entry.insert(0, "0")
        self.upper_entry.insert(0, "1.5")
       
        action_card = self.create_modern_card(parent, "üöÄ Acciones R√°pidas")
       
        ModernButton(action_card, text="üé® Graficar con √Årea",
                   command=self.on_plot, style="Accent.TButton").pack(fill=tk.X, pady=5)
       
        ModernButton(action_card, text="üîç Analizar Puntos",
                   command=self.on_analyze_points, style="Modern.TButton").pack(fill=tk.X, pady=5)
       
        ModernButton(action_card, text="üìä Mostrar Info √Årea",
                   command=self.show_area_info, style="Modern.TButton").pack(fill=tk.X, pady=5)
       
        ModernButton(action_card, text="üßπ Limpiar Todo",
                   command=self.on_clear_all, style="Modern.TButton").pack(fill=tk.X, pady=5)
    def create_3d_tab(self, parent):
        func3d_card = self.create_modern_card(parent, "üåê Funci√≥n 3D z = f(x,y)")
        ttk.Label(func3d_card, text="Ingresa tu funci√≥n f(x,y):", style="Small.TLabel").pack(anchor='w', pady=(0, 5))
       
        self.func3d_entry = ModernEntry(func3d_card, font=("Consolas", 12))
        self.func3d_entry.pack(fill=tk.X, pady=(0, 10))
        self.func3d_entry.insert(0, "sin(x**2 + y**2)")
       
        range3d_card = self.create_modern_card(parent, "üìä Rango de Visualizaci√≥n 3D")
        range3d_frame = ttk.Frame(range3d_card, style="Card.TFrame")
        range3d_frame.pack(fill=tk.X, pady=5)
       
        # X range
        ttk.Label(range3d_frame, text="X min", style="Small.TLabel").grid(row=0, column=0, sticky='w')
        self.x3d_min_entry = ModernEntry(range3d_frame, width=10)
        self.x3d_min_entry.grid(row=1, column=0, padx=(0, 5), sticky='ew')
       
        ttk.Label(range3d_frame, text="X max", style="Small.TLabel").grid(row=0, column=1, sticky='w')
        self.x3d_max_entry = ModernEntry(range3d_frame, width=10)
        self.x3d_max_entry.grid(row=1, column=1, padx=(5, 0), sticky='ew')
       
        # Y range
        ttk.Label(range3d_frame, text="Y min", style="Small.TLabel").grid(row=2, column=0, sticky='w', pady=(10,0))
        self.y3d_min_entry = ModernEntry(range3d_frame, width=10)
        self.y3d_min_entry.grid(row=3, column=0, padx=(0, 5), sticky='ew', pady=(0,10))
       
        ttk.Label(range3d_frame, text="Y max", style="Small.TLabel").grid(row=2, column=1, sticky='w', pady=(10,0))
        self.y3d_max_entry = ModernEntry(range3d_frame, width=10)
        self.y3d_max_entry.grid(row=3, column=1, padx=(5, 0), sticky='ew', pady=(0,10))
       
        range3d_frame.columnconfigure((0, 1), weight=1)
        self.x3d_min_entry.insert(0, "-5")
        self.x3d_max_entry.insert(0, "5")
        self.y3d_min_entry.insert(0, "-5")
        self.y3d_max_entry.insert(0, "5")
       
        action3d_card = self.create_modern_card(parent, "üöÄ Acciones 3D")
       
        ModernButton(action3d_card, text="üåê Graficar 3D",
                   command=self.on_plot_3d, style="Accent.TButton").pack(fill=tk.X, pady=5)
       
        ModernButton(action3d_card, text="üßπ Limpiar Gr√°fica",
                   command=self.on_clear_all, style="Modern.TButton").pack(fill=tk.X, pady=5)
    def create_derivative_tab(self, parent):
        deriv_card = self.create_modern_card(parent, "üìà C√°lculo de Derivadas")
       
        ttk.Label(deriv_card, text="M√©todo de derivaci√≥n:", style="Small.TLabel").pack(anchor='w', pady=(5, 0))
        self.deriv_method = ModernCombobox(deriv_card, values=[
            "Auto (completo)",
            "Paso a paso completo",
            "Solo regla de la potencia",
            "Solo regla de la cadena",
            "Directo (SymPy)"
        ], state='readonly')
        self.deriv_method.pack(fill=tk.X, pady=5)
        self.deriv_method.set("Auto (completo)")
       
        ttk.Label(deriv_card, text="Orden:", style="Small.TLabel").pack(anchor='w', pady=(10, 0))
        self.deriv_order = ModernCombobox(deriv_card, values=["1","2","3","4"], state='readonly', width=8)
        self.deriv_order.pack(fill=tk.X, pady=5)
        self.deriv_order.set("1")
       
        ttk.Label(deriv_card, text="Evaluar en x =", style="Small.TLabel").pack(anchor='w', pady=(10, 0))
        self.eval_point = ModernEntry(deriv_card)
        self.eval_point.pack(fill=tk.X, pady=5)
        self.eval_point.insert(0, "1")
       
        ModernButton(deriv_card, text="üßÆ Calcular Derivada",
                   command=lambda: self.on_calculate("derivada"), style="Accent.TButton").pack(fill=tk.X, pady=15)
    def create_integral_tab(self, parent):
        integral_card = self.create_modern_card(parent, "üìä C√°lculo de Integrales")
       
        ttk.Label(integral_card, text="M√©todo de c√°lculo:", style="Small.TLabel").pack(anchor='w', pady=(5, 0))
        self.calc_type = ModernCombobox(integral_card, values=[
            "Auto (mejor intento)", "Integral indefinida", "Integral definida",
            "Integral impropia", "Sustituci√≥n", "Por partes", "Fracciones parciales",
            "Sust. trigonom√©trica", "Num√©rico (Simpson)"
        ], state='readonly')
        self.calc_type.pack(fill=tk.X, pady=5)
        self.calc_type.set("Auto (mejor intento)")
       
        ModernButton(integral_card, text="üìê Calcular Integral",
                   command=lambda: self.on_calculate("integral"), style="Accent.TButton").pack(fill=tk.X, pady=15)
    def create_physics_tab(self, parent):
        physics_card = self.create_modern_card(parent, "üåç Problemas de F√≠sica")
       
        ttk.Label(physics_card, text="Tipo de problema:", style="Small.TLabel").pack(anchor='w', pady=(5, 0))
        self.physics_problem = ModernCombobox(physics_card, values=[
            "Ca√≠da libre avanzada",
            "Movimiento de proyectil",
            "Movimiento rectil√≠neo",
            "Velocidad promedio",
            "Resistencia del aire",
            "An√°lisis de energ√≠a"
        ], state='readonly')
        self.physics_problem.pack(fill=tk.X, pady=5)
        self.physics_problem.set("Ca√≠da libre avanzada")
       
        self.physics_params_frame = ttk.Frame(physics_card, style="Card.TFrame")
        self.physics_params_frame.pack(fill=tk.X, pady=10)
       
        self.physics_problem.bind('<<ComboboxSelected>>', self._update_physics_params)
       
        physics_action_frame = ttk.Frame(physics_card, style="Card.TFrame")
        physics_action_frame.pack(fill=tk.X, pady=10)
       
        ModernButton(physics_action_frame, text="üî¨ Resolver Problema F√≠sico",
                   command=self.on_physics_calculate, style="Accent.TButton").pack(fill=tk.X, pady=5)
       
        self._update_physics_params()
    def create_settings_tab(self, parent):
        speed_card = self.create_modern_card(parent, "üé¨ Velocidad de Animaci√≥n")
       
        self.speed_var = tk.StringVar(value="normal")
        speeds = [("üê¢ Lenta", "slow"), ("üö∂ Normal", "normal"),
                 ("üêá R√°pida", "fast"), ("‚ö° Instant√°nea", "instant")]
       
        for text, value in speeds:
            ttk.Radiobutton(speed_card, text=text, variable=self.speed_var,
                          value=value, command=self.on_speed_change, style="TRadiobutton").pack(anchor='w', pady=2)
       
        toggle_card = self.create_modern_card(parent, "üéõÔ∏è Configuraci√≥n Visual")
       
        self.animation_var = tk.BooleanVar(value=False) # Desactivado por defecto
        ttk.Checkbutton(toggle_card, text="üé¨ Activar animaciones", variable=self.animation_var,
                       command=self.on_animation_toggle, style="Small.TLabel").pack(anchor='w', pady=5)
       
        self.velocity_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(toggle_card, text="üìä Mostrar l√≠nea de velocidad", variable=self.velocity_var,
                       command=self.on_velocity_toggle, style="Small.TLabel").pack(anchor='w', pady=5)
       
        examples_card = self.create_modern_card(parent, "üí° Ejemplos R√°pidos")
        examples = ["x**3 - 3*x + 2", "sin(x)*cos(x)", "exp(-x**2)", "1/(1+x**2)"]
       
        for ex in examples:
            btn = ModernButton(examples_card, text=ex,
                             command=lambda e=ex: self._set_example(e),
                             style="Modern.TButton")
            btn.pack(fill=tk.X, pady=2)
    def create_center_panel(self, parent):
        graph_frame = ttk.Frame(parent, style="Card.TFrame", padding=10)
        graph_frame.pack(fill=tk.BOTH, expand=True)
       
        self.graph_title = ttk.Label(graph_frame, text="üé® Gr√°fica Interactiva", style="CardHeader.TLabel")
        self.graph_title.pack(anchor='w', pady=(0, 10))
       
        self.fig, self.ax = plt.subplots(figsize=(8, 6), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.fig, master=graph_frame)
        canvas_widget = self.canvas.get_tk_widget()
        canvas_widget.pack(fill=tk.BOTH, expand=True)
       
        toolbar = NavigationToolbar2Tk(self.canvas, graph_frame)
        toolbar.update()
       
        self.plot_manager = ModernPlotManager(self.fig, self.ax, self.canvas, self.theme)
    def create_right_panel(self, parent):
        results_frame = ttk.Frame(parent, style="Card.TFrame", padding=10)
        results_frame.pack(fill=tk.BOTH, expand=True)
       
        title_frame = ttk.Frame(results_frame, style="Card.TFrame")
        title_frame.pack(fill=tk.X, pady=(0, 10))
       
        ttk.Label(title_frame, text="üìã Pasos y Resultados", style="CardHeader.TLabel").pack(side=tk.LEFT)
       
        self.steps_counter = ttk.Label(title_frame, text="0 pasos", style="Small.TLabel")
        self.steps_counter.pack(side=tk.RIGHT)
       
        text_frame = ttk.Frame(results_frame, style="Card.TFrame")
        text_frame.pack(fill=tk.BOTH, expand=True)
       
        self.steps_text = scrolledtext.ScrolledText(
            text_frame,
            wrap=tk.WORD,
            font=("Consolas", 10),
            bg=self.theme['card_bg'],
            fg=self.theme['text_primary'],
            insertbackground=self.theme['text_primary'],
            relief='flat',
            borderwidth=0,
            padx=10,
            pady=10,
            height=15 # Altura fija para mejor organizaci√≥n
        )
        self.steps_text.pack(fill=tk.BOTH, expand=True)
       
        # Configurar tags para estilizado
        self.steps_text.tag_configure("title", foreground=self.theme['accent'], font=("Segoe UI", 12, "bold"))
        self.steps_text.tag_configure("step", foreground=self.theme['text_secondary'], font=("Consolas", 10))
        self.steps_text.tag_configure("result", foreground=self.theme['success'], font=("Consolas", 10, "bold"))
        self.steps_text.tag_configure("area", foreground=self.theme['accent_tertiary'], font=("Consolas", 10, "bold"))
       
        export_frame = ttk.Frame(results_frame, style="Card.TFrame")
        export_frame.pack(fill=tk.X, pady=(10, 0))
       
        ModernButton(export_frame, text="üìÑ Exportar Resultados",
                   command=self.export_steps, style="Modern.TButton").pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
       
        ModernButton(export_frame, text="üñºÔ∏è Exportar Gr√°fica",
                   command=self.export_plot, style="Modern.TButton").pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(5, 0))
    def create_status_bar(self):
        status_frame = tk.Frame(self.root, bg=self.theme['card_bg'], height=30)
        status_frame.pack(fill=tk.X, side=tk.BOTTOM)
        status_frame.pack_propagate(False)
       
        self.status_var = tk.StringVar(value="üöÄ Listo para calcular...")
        status_label = tk.Label(status_frame, textvariable=self.status_var,
                              bg=self.theme['card_bg'], fg=self.theme['text_secondary'],
                              font=("Segoe UI", 9))
        status_label.pack(side=tk.LEFT, padx=15, pady=5)
       
        # Informaci√≥n del √°rea actual
        self.area_info_var = tk.StringVar(value="√Årea: No calculada")
        area_label = tk.Label(status_frame, textvariable=self.area_info_var,
                            bg=self.theme['card_bg'], fg=self.theme['accent_tertiary'],
                            font=("Segoe UI", 9))
        area_label.pack(side=tk.RIGHT, padx=15, pady=5)
    def create_modern_card(self, parent, title):
        card = ttk.Frame(parent, style="Card.TFrame", padding=15)
        card.pack(fill=tk.X, pady=8)
       
        if title:
            title_label = ttk.Label(card, text=title, style="CardHeader.TLabel")
            title_label.pack(anchor='w', pady=(0, 10))
       
        return card
    def toggle_theme(self):
        if self.theme_mode == "dark":
            self.theme_mode = "light"
            self.theme = AppConfig.LIGHT_THEME
            self.theme_btn.config(text="‚òÄÔ∏è Modo D√≠a")
        else:
            self.theme_mode = "dark"
            self.theme = AppConfig.DARK_THEME
            self.theme_btn.config(text="üåô Modo Noche")
       
        self.setup_styles()
        self.plot_manager.theme = self.theme
        if self.plot_manager.current_plot_type == "3d":
            self.plot_manager._apply_3d_style()
        else:
            self.plot_manager._apply_modern_style()
        self.plot_manager.canvas.draw_idle()
        self.steps_text.config(bg=self.theme['card_bg'], fg=self.theme['text_primary'])
        self._set_status("Tema cambiado correctamente ‚ú®")
    def on_speed_change(self):
        speed_map = {
            "slow": AnimationSpeed.SLOW,
            "normal": AnimationSpeed.NORMAL,
            "fast": AnimationSpeed.FAST,
            "instant": AnimationSpeed.INSTANT
        }
       
        new_speed = speed_map.get(self.speed_var.get(), AnimationSpeed.NORMAL)
        self.plot_manager.set_animation_speed(new_speed)
       
        speed_names = {
            "slow": "Lenta üê¢",
            "normal": "Normal üö∂",
            "fast": "R√°pida üêá",
            "instant": "Instant√°nea ‚ö°"
        }
       
        self._set_status(f"Velocidad: {speed_names[self.speed_var.get()]}", clear_after_ms=2000)
    def on_animation_toggle(self):
        new_state = self.plot_manager.toggle_animation()
        status = "activadas üé¨" if new_state else "desactivadas"
        self._set_status(f"Animaciones {status}", clear_after_ms=2000)
    def on_velocity_toggle(self):
        new_state = self.plot_manager.toggle_velocity()
        status = "activada üìä" if new_state else "desactivada"
        self._set_status(f"L√≠nea de velocidad {status}", clear_after_ms=2000)
    def _update_physics_params(self, event=None):
        for widget in self.physics_params_frame.winfo_children():
            widget.destroy()
       
        problem_type = self.physics_problem.get()
       
        if problem_type == "Ca√≠da libre avanzada":
            ttk.Label(self.physics_params_frame, text="Altura (metros):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "100")
           
            ttk.Label(self.physics_params_frame, text="Velocidad inicial (m/s, opcional):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "0")
           
            ttk.Label(self.physics_params_frame, text="Masa (kg, opcional):", style="Small.TLabel").pack(anchor='w')
            self.physics_param3 = ModernEntry(self.physics_params_frame)
            self.physics_param3.pack(fill=tk.X, pady=5)
            self.physics_param3.insert(0, "1.0")
           
        elif problem_type == "Movimiento de proyectil":
            ttk.Label(self.physics_params_frame, text="Velocidad inicial (m/s):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "50")
           
            ttk.Label(self.physics_params_frame, text="√Ångulo (grados):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "45")
           
            ttk.Label(self.physics_params_frame, text="Altura inicial (m, opcional):", style="Small.TLabel").pack(anchor='w')
            self.physics_param3 = ModernEntry(self.physics_params_frame)
            self.physics_param3.pack(fill=tk.X, pady=5)
            self.physics_param3.insert(0, "0")
           
        elif problem_type == "Movimiento rectil√≠neo":
            ttk.Label(self.physics_params_frame, text="Velocidad inicial (m/s):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "10")
           
            ttk.Label(self.physics_params_frame, text="Aceleraci√≥n (m/s¬≤):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "2")
           
            ttk.Label(self.physics_params_frame, text="Tiempo (segundos):", style="Small.TLabel").pack(anchor='w')
            self.physics_param3 = ModernEntry(self.physics_params_frame)
            self.physics_param3.pack(fill=tk.X, pady=5)
            self.physics_param3.insert(0, "5")
           
        elif problem_type == "Velocidad promedio":
            ttk.Label(self.physics_params_frame, text="Distancia total (metros):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "1000")
           
            ttk.Label(self.physics_params_frame, text="Tiempo total (segundos):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "60")
           
        elif problem_type == "Resistencia del aire":
            ttk.Label(self.physics_params_frame, text="Masa (kg):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "1")
           
            ttk.Label(self.physics_params_frame, text="√Årea frontal (m¬≤):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "0.1")
           
            ttk.Label(self.physics_params_frame, text="Velocidad (m/s, opcional):", style="Small.TLabel").pack(anchor='w')
            self.physics_param3 = ModernEntry(self.physics_params_frame)
            self.physics_param3.pack(fill=tk.X, pady=5)
            self.physics_param3.insert(0, "10")
           
        elif problem_type == "An√°lisis de energ√≠a":
            ttk.Label(self.physics_params_frame, text="Masa (kg):", style="Small.TLabel").pack(anchor='w')
            self.physics_param1 = ModernEntry(self.physics_params_frame)
            self.physics_param1.pack(fill=tk.X, pady=5)
            self.physics_param1.insert(0, "1.0")
           
            ttk.Label(self.physics_params_frame, text="Velocidad (m/s):", style="Small.TLabel").pack(anchor='w')
            self.physics_param2 = ModernEntry(self.physics_params_frame)
            self.physics_param2.pack(fill=tk.X, pady=5)
            self.physics_param2.insert(0, "10")
    def _set_status(self, message, clear_after_ms=None):
        self.status_var.set(f"üì¢ {message}")
        if clear_after_ms:
            self.root.after(clear_after_ms, lambda: self.status_var.set("üöÄ Listo"))
    def _set_example(self, example):
        self.func_entry.delete(0, tk.END)
        self.func_entry.insert(0, example)
    def on_plot(self):
        try:
            func_str = self.func_entry.get().strip()
            if not func_str:
                raise ValueError("¬°Ingresa una funci√≥n para graficar!")
           
            xmin = float(self.xmin_entry.get())
            xmax = float(self.xmax_entry.get())
           
            lower_raw = self.lower_entry.get().strip()
            upper_raw = self.upper_entry.get().strip()
            a = parse_limit_string(lower_raw) if lower_raw else None
            b = parse_limit_string(upper_raw) if upper_raw else None
           
            self._set_status("üé® Generando visualizaci√≥n...")
            self.plot_manager.clear()
           
            self.graph_title.config(text=f"üìä Gr√°fica: {func_str}")
           
            self.plot_manager.plot_function(
                func_str,
                xlim=(xmin, xmax),
                color_index=0,
                animate=False, # Desactivado por defecto
                show_area=True,
                area_limits=(a, b)
            )
           
            # Mostrar informaci√≥n del √°rea autom√°ticamente
            area_info = self.plot_manager.get_area_info()
            if area_info:
                self.area_info_var.set(f"√Årea neta: {area_info.get('area_neta', 0):.6f}")
                self._append_steps([
                    f"üìä √ÅREA BAJO LA CURVA CALCULADA:",
                    f"‚Ä¢ √Årea sobre curva: {area_info.get('area_positiva', 0):.8f}",
                    f"‚Ä¢ √Årea bajo curva: {area_info.get('area_negativa', 0):.8f}",
                    f"‚Ä¢ √Årea neta: {area_info.get('area_neta', 0):.8f}",
                    f"‚Ä¢ √Årea total: {area_info.get('area_absoluta', 0):.8f}",
                    f"‚Ä¢ Distribuci√≥n: {area_info.get('porcentaje_positivo', 0):.1f}% positiva, {area_info.get('porcentaje_negativo', 0):.1f}% negativa"
                ], "üìä AN√ÅLISIS DE √ÅREA")
           
            self._set_status("‚úÖ Gr√°fica generada exitosamente!")
           
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo generar la gr√°fica:\n{str(e)}")
            self._set_status("‚ùå Error en la gr√°fica")
    def on_plot_3d(self):
        try:
            func_str = self.func3d_entry.get().strip()
            if not func_str:
                raise ValueError("¬°Ingresa una funci√≥n 3D para graficar!")
           
            x_min = float(self.x3d_min_entry.get())
            x_max = float(self.x3d_max_entry.get())
            y_min = float(self.y3d_min_entry.get())
            y_max = float(self.y3d_max_entry.get())
           
            self._set_status("üåê Generando visualizaci√≥n 3D...")
            self.plot_manager.clear()
           
            self.graph_title.config(text=f"üåê Gr√°fica 3D: {func_str}")
           
            self.plot_manager.plot_3d_function(
                func_str,
                xlims=(x_min, x_max),
                ylims=(y_min, y_max)
            )
           
            self._append_steps([f"üåê Gr√°fica 3D generada para z = {func_str}"], "üåê GR√ÅFICA 3D")
           
            self._set_status("‚úÖ Gr√°fica 3D generada exitosamente!")
           
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo generar la gr√°fica 3D:\n{str(e)}")
            self._set_status("‚ùå Error en la gr√°fica 3D")
    def show_area_info(self):
        """Muestra informaci√≥n detallada del √°rea"""
        area_info = self.plot_manager.get_area_info()
        if not area_info:
            messagebox.showinfo("Informaci√≥n", "No hay informaci√≥n de √°rea disponible. Calcule un √°rea primero.")
            return
       
        info_text = f"""
üìä INFORMACI√ìN DETALLADA DEL √ÅREA:
‚îå √ÅREA SOBRE CURVA (positiva):
‚îÇ Valor: {area_info.get('area_positiva', 0):.8f}
‚îÇ Porcentaje: {area_info.get('porcentaje_positivo', 0):.1f}%
‚îú √ÅREA BAJO CURVA (negativa):
‚îÇ Valor: {area_info.get('area_negativa', 0):.8f}
‚îÇ Porcentaje: {area_info.get('porcentaje_negativo', 0):.1f}%
‚îú √ÅREA NETA (positiva - negativa):
‚îÇ Valor: {area_info.get('area_neta', 0):.8f}
‚îî √ÅREA ABSOLUTA (total):
    Valor: {area_info.get('area_absoluta', 0):.8f}
üí° El √°rea neta puede ser positiva, negativa o cero.
   El √°rea absoluta siempre es positiva.
"""
        self.steps_text.delete('1.0', tk.END)
        self._append_steps([info_text], "üìä AN√ÅLISIS DE √ÅREA DETALLADO")
    def on_calculate(self, calc_type):
        try:
            func_str = self.func_entry.get().strip()
            if not func_str:
                raise ValueError("Ingresa una funci√≥n para calcular.")
           
            self.steps_text.delete('1.0', tk.END)
           
            if calc_type == "derivada":
                order = int(self.deriv_order.get())
                point_str = self.eval_point.get().strip()
                method = self.deriv_method.get()
               
                method_map = {
                    "Auto (completo)": "completo",
                    "Paso a paso completo": "completo",
                    "Solo regla de la potencia": "regla_potencia",
                    "Solo regla de la cadena": "regla_cadena",
                    "Directo (SymPy)": "directo"
                }
               
                solver_method = method_map.get(method, "directo")
               
                if point_str:
                    point = float(point_str)
                    res, steps = self.engine.eval_derivative(func_str, point, order, solver_method)
                else:
                    res, steps = self.engine.derivative(func_str, order, solver_method)
                       
            else: # integral
                method = self.calc_type.get()
               
                if method == "Auto (mejor intento)":
                    res, steps = self.engine.indefinite(func_str)
                elif method == "Integral indefinida":
                    res, steps = self.engine.indefinite(func_str)
                elif method == "Integral definida":
                    a = parse_limit_string(self.lower_entry.get())
                    b = parse_limit_string(self.upper_entry.get())
                    res, steps = self.engine.definite(func_str, a, b)
                elif method == "Integral impropia":
                    a = parse_limit_string(self.lower_entry.get())
                    b = parse_limit_string(self.upper_entry.get())
                    res, steps = self.engine.improper(func_str, a, b)
                elif method == "Sustituci√≥n":
                    res, steps = self.engine.substitution_auto(func_str)
                elif method == "Por partes":
                    res, steps = self.engine.integration_by_parts_auto(func_str)
                elif method == "Fracciones parciales":
                    res, steps = self.engine.partial_fractions(func_str)
                elif method == "Sust. trigonom√©trica":
                    res, steps = self.engine.trig_substitution(func_str)
                else: # Num√©rico (Simpson)
                    a = parse_limit_string(self.lower_entry.get())
                    b = parse_limit_string(self.upper_entry.get())
                    res, steps = self.engine.numeric_simpson(func_str, a, b)
           
            self._append_steps(steps, f"üßÆ {calc_type.upper()}")
            self._set_status("‚úÖ C√°lculo completado!")
           
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo realizar el c√°lculo:\n{str(e)}")
            self._set_status("‚ùå Error en el c√°lculo")
    def on_physics_calculate(self):
        try:
            problem_type = self.physics_problem.get()
           
            if problem_type == "Ca√≠da libre avanzada":
                altura = float(self.physics_param1.get())
                velocidad_inicial = float(self.physics_param2.get() or "0")
                masa = float(self.physics_param3.get() or "1.0")
               
                result = self.engine.physics.caida_libre_tiempo(altura, velocidad_inicial, masa=masa)
                steps = [
                    f"üåç CA√çDA LIBRE AVANZADA - Con resistencia del aire",
                    f"Altura inicial: {altura:.4f} m",
                    f"Velocidad inicial: {velocidad_inicial:.4f} m/s",
                    f"Masa: {masa:.4f} kg",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Tiempo sin resistencia: {result['tiempo_sin_resistencia']:.6f} s",
                    f"‚Ä¢ Tiempo con resistencia: {result['tiempo_con_resistencia']:.6f} s",
                    f"‚Ä¢ Diferencia: {result['diferencia_tiempo']:.6f} s ({result['diferencia_tiempo']/result['tiempo_sin_resistencia']*100:.1f}%)",
                    f"‚Ä¢ Velocidad de impacto: {result['velocidad_impacto']:.6f} m/s",
                    f"‚Ä¢ Energ√≠a cin√©tica: {result['energia_cinetica']:.6f} J",
                    f"",
                    f"üí° La resistencia del aire aumenta el tiempo de ca√≠da en {result['diferencia_tiempo']:.3f} segundos."
                ]
               
                self.plot_manager.plot_physics_motion(result, 'caida_libre')
               
            elif problem_type == "Movimiento de proyectil":
                velocidad = float(self.physics_param1.get())
                angulo = float(self.physics_param2.get())
                altura_inicial = float(self.physics_param3.get() or "0")
               
                result = self.engine.physics.movimiento_proyectil(velocidad, angulo, altura_inicial)
                steps = [
                    f"üöÄ MOVIMIENTO DE PROYECTIL",
                    f"Velocidad inicial: {velocidad:.4f} m/s",
                    f"√Ångulo: {angulo:.4f}¬∞",
                    f"Altura inicial: {altura_inicial:.4f} m",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Alcance: {result['alcance']:.6f} m",
                    f"‚Ä¢ Altura m√°xima: {result['altura_maxima']:.6f} m",
                    f"‚Ä¢ Tiempo de vuelo: {result['tiempo_vuelo']:.6f} s",
                    f"",
                    f"üí° El proyectil alcanza {result['altura_maxima']:.1f} metros de altura."
                ]
               
            elif problem_type == "Movimiento rectil√≠neo":
                velocidad_inicial = float(self.physics_param1.get())
                aceleracion = float(self.physics_param2.get())
                tiempo = float(self.physics_param3.get())
               
                result = self.engine.physics.movimiento_rectilineo(velocidad_inicial, aceleracion, tiempo)
                steps = [
                    f"üìè MOVIMIENTO RECTIL√çNEO UNIFORMEMENTE ACELERADO",
                    f"Velocidad inicial: {velocidad_inicial:.4f} m/s",
                    f"Aceleraci√≥n: {aceleracion:.4f} m/s¬≤",
                    f"Tiempo: {tiempo:.4f} s",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Desplazamiento: {result['desplazamiento']:.6f} m",
                    f"‚Ä¢ Velocidad final: {result['velocidad_final']:.6f} m/s",
                    f"‚Ä¢ Energ√≠a cin√©tica inicial: {result['energia_cinetica_inicial']:.6f}",
                    f"‚Ä¢ Energ√≠a cin√©tica final: {result['energia_cinetica_final']:.6f}",
                    f"‚Ä¢ Trabajo neto: {result['trabajo']:.6f}",
                    f"",
                    f"üí° Se requiere {result['trabajo']:.1f} Julios de trabajo."
                ]
               
                self.plot_manager.plot_physics_motion(result, 'movimiento_rectilineo')
               
            elif problem_type == "Velocidad promedio":
                distancia = float(self.physics_param1.get())
                tiempo = float(self.physics_param2.get())
               
                result = self.engine.physics.velocidad_promedio(distancia, tiempo)
                steps = [
                    f"üìè VELOCIDAD PROMEDIO",
                    f"Distancia total: {distancia:.4f} m",
                    f"Tiempo total: {tiempo:.4f} s",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Velocidad promedio: {result['velocidad_promedio']:.6f} m/s",
                    f"‚Ä¢ En km/h: {result['kmh']:.6f}",
                    f"‚Ä¢ En mph: {result['mph']:.6f}",
                ]
               
            elif problem_type == "Resistencia del aire":
                masa = float(self.physics_param1.get())
                area = float(self.physics_param2.get())
                velocidad = float(self.physics_param3.get() or "10")
               
                result = self.engine.physics.resistencia_aire_aproximada(masa, area, velocidad=velocidad)
                steps = [
                    f"üí® RESISTENCIA DEL AIRE (Aproximaci√≥n Ingenier√≠a)",
                    f"Masa del objeto: {masa:.4f} kg",
                    f"√Årea frontal: {area:.4f} m¬≤",
                    f"Velocidad: {velocidad:.4f} m/s",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Fuerza de resistencia: {result['fuerza_resistencia']:.6f} N",
                    f"‚Ä¢ Peso del objeto: {result['peso']:.6f} N",
                    f"‚Ä¢ Velocidad terminal: {result['velocidad_terminal']:.6f} m/s",
                    f"‚Ä¢ Tiempo aprox. a terminal: {result['tiempo_aprox_terminal']:.6f} s",
                    f"‚Ä¢ Trayectoria simulada (posiciones finales): {result['trayectoria'][-1]:.6f} m"
                ]
           
            elif problem_type == "An√°lisis de energ√≠a":
                masa = float(self.physics_param1.get())
                velocidad = float(self.physics_param2.get())
               
                result = self.engine.physics.analisis_energia_cinetica(masa, velocidad)
                steps = [
                    f"‚ö° AN√ÅLISIS DE ENERG√çA CIN√âTICA",
                    f"Masa: {masa:.4f} kg",
                    f"Velocidad: {velocidad:.4f} m/s",
                    f"",
                    f"üìä RESULTADOS:",
                    f"‚Ä¢ Energ√≠a cin√©tica: {result['energia_cinetica']:.6f} J",
                    f"‚Ä¢ Momento lineal: {result['momento_lineal']:.6f} kg¬∑m/s",
                    f"‚Ä¢ Presi√≥n de impacto: {result['presion_impacto']:.6f} Pa",
                    f"‚Ä¢ Equivalente en TNT: {result['equivalente_tnt']:.10f} kg",
                    f"",
                    f"üí° Esta energ√≠a equivale a {result['equivalente_tnt']*1000:.3f} gramos de TNT."
                ]
           
            self.steps_text.delete('1.0', tk.END)
            self._append_steps(steps, f"üåç F√çSICA: {problem_type}")
           
            self._set_status("‚úÖ C√°lculo de f√≠sica completado", clear_after_ms=3000)
           
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo resolver el problema:\n{e}")
    def on_analyze_points(self):
        try:
            func_str = self.func_entry.get().strip()
            if not func_str:
                raise ValueError("Ingresa una funci√≥n para analizar.")
           
            xmin = float(self.xmin_entry.get())
            xmax = float(self.xmax_entry.get())
           
            self._set_status(f"üîç Analizando {func_str}...")
            analysis = self.engine.critical_points(func_str, xlim=(xmin, xmax))
           
            self.steps_text.delete('1.0', tk.END)
            self._append_steps([f"An√°lisis de f(x) = {func_str}"], "üìä AN√ÅLISIS DE PUNTOS")
           
            all_points = []
           
            if analysis['interseccion_y'] and analysis['interseccion_y'].get('y') is not None:
                iy = analysis['interseccion_y']
                self.steps_text.insert(tk.END, f"\n‚Ä¢ Intersecci√≥n Y: ({iy['x']:.6f}, {iy['y']:.6f})\n")
                all_points.append(iy)
           
            if analysis['raices']:
                self.steps_text.insert(tk.END, f"\n‚Ä¢ Ra√≠ces encontradas: {len(analysis['raices'])}\n")
                for r in analysis['raices']:
                    self.steps_text.insert(tk.END, f" - ({r['x']:.6f}, {r['y']:.6f})\n")
                    all_points.append(r)
           
            if analysis['puntos_criticos']:
                self.steps_text.insert(tk.END, f"\n‚Ä¢ Puntos cr√≠ticos: {len(analysis['puntos_criticos'])}\n")
                for pc in analysis['puntos_criticos']:
                    self.steps_text.insert(tk.END, f" - {pc['tipo']}: ({pc['x']:.6f}, {pc['y']:.6f}) - Curvatura: {pc['curvatura']:.6f}\n")
                    all_points.append(pc)
           
            self.plot_manager.mark_points(all_points, animate=False) # Desactivado
            self._set_status("‚úÖ An√°lisis completado!", clear_after_ms=3000)
           
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo analizar la funci√≥n:\n{e}")
    def _append_steps(self, steps, title=None):
        if title:
            self.steps_text.insert(tk.END, f"{title}\n", "title")
            self.steps_text.insert(tk.END, "="*len(title) + "\n\n")
       
        for step in steps:
            if "√ÅREA" in step.upper() or "AREA" in step.upper():
                self.steps_text.insert(tk.END, f"{step}\n", "area")
            elif "RESULTADO" in step.upper() or "VERIFICACI√ìN" in step.upper():
                self.steps_text.insert(tk.END, f"{step}\n", "result")
            else:
                self.steps_text.insert(tk.END, f"{step}\n", "step")
       
        self.steps_text.insert(tk.END, f"\n{'='*50}\n\n")
        self.steps_text.see(tk.END)
    def export_steps(self):
        try:
            content = self.steps_text.get('1.0', tk.END).strip()
            if not content:
                messagebox.showinfo("Info", "No hay contenido para exportar.")
                return
           
            filename = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Archivos de texto", "*.txt")]
            )
           
            if filename:
                with open(filename, 'w', encoding='utf-8') as f:
                    f.write("ULTRA CALC 2D - RESULTADOS\n")
                    f.write("="*50 + "\n\n")
                    f.write(content)
               
                self._set_status("‚úÖ Resultados exportados!")
                messagebox.showinfo("√âxito", f"Resultados guardados en:\n{filename}")
               
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo exportar:\n{str(e)}")
    def export_plot(self):
        try:
            filename = filedialog.asksaveasfilename(
                defaultextension=".png",
                filetypes=[("PNG", "*.png"), ("PDF", "*.pdf")]
            )
           
            if filename:
                self.fig.savefig(filename, dpi=300, bbox_inches='tight',
                               facecolor=self.theme['plot_bg'])
                self._set_status("‚úÖ Gr√°fica exportada!")
                messagebox.showinfo("√âxito", f"Gr√°fica guardada en:\n{filename}")
               
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo exportar la gr√°fica:\n{str(e)}")
    def on_clear_all(self):
        """Limpieza completa que incluye gr√°ficas de f√≠sica"""
        self.plot_manager.clear()
        self.steps_text.delete('1.0', tk.END)
        self.graph_title.config(text="üé® Gr√°fica Interactiva")
        self.area_info_var.set("√Årea: No calculada")
        self._set_status("üßπ Todo limpiado!", clear_after_ms=2000)
# ----------------------- EJECUCI√ìN PRINCIPAL -----------------------
if __name__ == "__main__":
    try:
        print("üöÄ INICIANDO ULTRA CALC 2D - VERSI√ìN MEJORADA...")
        print("üé® Cargando interfaz moderna...")
        print("üßÆ Inicializando motor matem√°tico avanzado...")
        print("üåç Configurando f√≠sica profesional...")
       
        root = tk.Tk()
        app = UltraCalc2DModernApp(root)
       
        print("‚úÖ SISTEMA MEJORADO LISTO!")
        print("üí° NUEVAS CARACTER√çSTICAS:")
        print(" ‚Ä¢ Calculadora compacta y eficiente")
        print(" ‚Ä¢ F√≠sica avanzada con resistencia del aire")
        print(" ‚Ä¢ Gr√°ficas modernas y atractivas")
        print(" ‚Ä¢ Informaci√≥n detallada de √°reas")
        print(" ‚Ä¢ An√°lisis de √°rea sobre y bajo la curva")
        print(" ‚Ä¢ Visualizaci√≥n mejorada con patrones")
        print(" ‚Ä¢ Informaci√≥n num√©rica en gr√°ficas")
        print(" ‚Ä¢ Presentaci√≥n m√°s ordenada y profesional")
        print(" ‚Ä¢ Gr√°ficas 3D interactivas")
       
        root.mainloop()
       
    except Exception as e:
        print(f"‚ùå ERROR: {e}")
        print("üí° Verifica las dependencias: pip install numpy sympy matplotlib tkinter pillow scipy")
